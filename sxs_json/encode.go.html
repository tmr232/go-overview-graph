<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>encode.go Graph Overview</title>
    <style>
        td {
            vertical-align: top;
        }

        pre {
            padding-right: 200px;
        }

        td {
            border-top: solid 1px blue;
        }
    </style>
</head>
<body>
<h1>
    File: <code>encode.go</code>
</h1>
<table>
    
        <tr>
            <td>
            <pre>// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package json implements encoding and decoding of JSON as defined in
// RFC 7159. The mapping between JSON and Go values is described
// in the documentation for the Marshal and Unmarshal functions.
//
// See &#34;JSON and Go&#34; for an introduction to this package:
// https://golang.org/doc/articles/json_and_go.html
package json

import (
	&#34;bytes&#34;
	&#34;encoding&#34;
	&#34;encoding/base64&#34;
	&#34;fmt&#34;
	&#34;math&#34;
	&#34;reflect&#34;
	&#34;sort&#34;
	&#34;strconv&#34;
	&#34;strings&#34;
	&#34;sync&#34;
	&#34;unicode&#34;
	&#34;unicode/utf8&#34;
)

// Marshal returns the JSON encoding of v.
//
// Marshal traverses the value v recursively.
// If an encountered value implements the Marshaler interface
// and is not a nil pointer, Marshal calls its MarshalJSON method
// to produce JSON. If no MarshalJSON method is present but the
// value implements encoding.TextMarshaler instead, Marshal calls
// its MarshalText method and encodes the result as a JSON string.
// The nil pointer exception is not strictly necessary
// but mimics a similar, necessary exception in the behavior of
// UnmarshalJSON.
//
// Otherwise, Marshal uses the following type-dependent default encodings:
//
// Boolean values encode as JSON booleans.
//
// Floating point, integer, and Number values encode as JSON numbers.
//
// String values encode as JSON strings coerced to valid UTF-8,
// replacing invalid bytes with the Unicode replacement rune.
// So that the JSON will be safe to embed inside HTML &lt;script&gt; tags,
// the string is encoded using HTMLEscape,
// which replaces &#34;&lt;&#34;, &#34;&gt;&#34;, &#34;&amp;&#34;, U&#43;2028, and U&#43;2029 are escaped
// to &#34;\u003c&#34;,&#34;\u003e&#34;, &#34;\u0026&#34;, &#34;\u2028&#34;, and &#34;\u2029&#34;.
// This replacement can be disabled when using an Encoder,
// by calling SetEscapeHTML(false).
//
// Array and slice values encode as JSON arrays, except that
// []byte encodes as a base64-encoded string, and a nil slice
// encodes as the null JSON value.
//
// Struct values encode as JSON objects.
// Each exported struct field becomes a member of the object, using the
// field name as the object key, unless the field is omitted for one of the
// reasons given below.
//
// The encoding of each struct field can be customized by the format string
// stored under the &#34;json&#34; key in the struct field&#39;s tag.
// The format string gives the name of the field, possibly followed by a
// comma-separated list of options. The name may be empty in order to
// specify options without overriding the default field name.
//
// The &#34;omitempty&#34; option specifies that the field should be omitted
// from the encoding if the field has an empty value, defined as
// false, 0, a nil pointer, a nil interface value, and any empty array,
// slice, map, or string.
//
// As a special case, if the field tag is &#34;-&#34;, the field is always omitted.
// Note that a field with name &#34;-&#34; can still be generated using the tag &#34;-,&#34;.
//
// Examples of struct field tags and their meanings:
//
//   // Field appears in JSON as key &#34;myName&#34;.
//   Field int `json:&#34;myName&#34;`
//
//   // Field appears in JSON as key &#34;myName&#34; and
//   // the field is omitted from the object if its value is empty,
//   // as defined above.
//   Field int `json:&#34;myName,omitempty&#34;`
//
//   // Field appears in JSON as key &#34;Field&#34; (the default), but
//   // the field is skipped if empty.
//   // Note the leading comma.
//   Field int `json:&#34;,omitempty&#34;`
//
//   // Field is ignored by this package.
//   Field int `json:&#34;-&#34;`
//
//   // Field appears in JSON as key &#34;-&#34;.
//   Field int `json:&#34;-,&#34;`
//
// The &#34;string&#34; option signals that a field is stored as JSON inside a
// JSON-encoded string. It applies only to fields of string, floating point,
// integer, or boolean types. This extra level of encoding is sometimes used
// when communicating with JavaScript programs:
//
//    Int64String int64 `json:&#34;,string&#34;`
//
// The key name will be used if it&#39;s a non-empty string consisting of
// only Unicode letters, digits, and ASCII punctuation except quotation
// marks, backslash, and comma.
//
// Anonymous struct fields are usually marshaled as if their inner exported fields
// were fields in the outer struct, subject to the usual Go visibility rules amended
// as described in the next paragraph.
// An anonymous struct field with a name given in its JSON tag is treated as
// having that name, rather than being anonymous.
// An anonymous struct field of interface type is treated the same as having
// that type as its name, rather than being anonymous.
//
// The Go visibility rules for struct fields are amended for JSON when
// deciding which field to marshal or unmarshal. If there are
// multiple fields at the same level, and that level is the least
// nested (and would therefore be the nesting level selected by the
// usual Go rules), the following extra rules apply:
//
// 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,
// even if there are multiple untagged fields that would otherwise conflict.
//
// 2) If there is exactly one field (tagged or not according to the first rule), that is selected.
//
// 3) Otherwise there are multiple fields, and all are ignored; no error occurs.
//
// Handling of anonymous struct fields is new in Go 1.1.
// Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of
// an anonymous struct field in both current and earlier versions, give the field
// a JSON tag of &#34;-&#34;.
//
// Map values encode as JSON objects. The map&#39;s key type must either be a
// string, an integer type, or implement encoding.TextMarshaler. The map keys
// are sorted and used as JSON object keys by applying the following rules,
// subject to the UTF-8 coercion described for string values above:
//   - keys of any string type are used directly
//   - encoding.TextMarshalers are marshaled
//   - integer keys are converted to strings
//
// Pointer values encode as the value pointed to.
// A nil pointer encodes as the null JSON value.
//
// Interface values encode as the value contained in the interface.
// A nil interface value encodes as the null JSON value.
//
// Channel, complex, and function values cannot be encoded in JSON.
// Attempting to encode such a value causes Marshal to return
// an UnsupportedTypeError.
//
// JSON cannot represent cyclic data structures and Marshal does not
// handle them. Passing cyclic structures to Marshal will result in
// an error.
//
</pre>
            </td>
            <td>
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Marshal(v any) ([]byte, error) {
	e := newEncodeState()

	err := e.marshal(v, encOpts{escapeHTML: true})
	if err != nil {
		return nil, err
	}
	buf := append([]byte(nil), e.Bytes()...)

	encodeStatePool.Put(e)

	return buf, nil
}

// MarshalIndent is like Marshal but applies Indent to format the output.
// Each JSON element in the output will begin on a new line beginning with prefix
// followed by one or more copies of indent according to the indentation nesting.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Marshal.png" alt="Control flow graph of Marshal">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func MarshalIndent(v any, prefix, indent string) ([]byte, error) {
	b, err := Marshal(v)
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	err = Indent(&amp;buf, b, prefix, indent)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// HTMLEscape appends to dst the JSON-encoded src with &lt;, &gt;, &amp;, U&#43;2028 and U&#43;2029
// characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029
// so that the JSON will be safe to embed inside HTML &lt;script&gt; tags.
// For historical reasons, web browsers don&#39;t honor standard HTML
// escaping within &lt;script&gt; tags, so an alternative JSON encoding must
// be used.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.MarshalIndent.png" alt="Control flow graph of MarshalIndent">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func HTMLEscape(dst *bytes.Buffer, src []byte) {
	// The characters can only appear in string literals,
	// so just scan the string one byte at a time.
	start := 0
	for i, c := range src {
		if c == &#39;&lt;&#39; || c == &#39;&gt;&#39; || c == &#39;&amp;&#39; {
			if start &lt; i {
				dst.Write(src[start:i])
			}
			dst.WriteString(`\u00`)
			dst.WriteByte(hex[c&gt;&gt;4])
			dst.WriteByte(hex[c&amp;0xF])
			start = i &#43; 1
		}
		// Convert U&#43;2028 and U&#43;2029 (E2 80 A8 and E2 80 A9).
		if c == 0xE2 &amp;&amp; i&#43;2 &lt; len(src) &amp;&amp; src[i&#43;1] == 0x80 &amp;&amp; src[i&#43;2]&amp;^1 == 0xA8 {
			if start &lt; i {
				dst.Write(src[start:i])
			}
			dst.WriteString(`\u202`)
			dst.WriteByte(hex[src[i&#43;2]&amp;0xF])
			start = i &#43; 3
		}
	}
	if start &lt; len(src) {
		dst.Write(src[start:])
	}
}

// Marshaler is the interface implemented by types that
// can marshal themselves into valid JSON.
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}

// An UnsupportedTypeError is returned by Marshal when attempting
// to encode an unsupported value type.
type UnsupportedTypeError struct {
	Type reflect.Type
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.HTMLEscape.png" alt="Control flow graph of HTMLEscape">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *UnsupportedTypeError) Error() string {
	return &#34;json: unsupported type: &#34; &#43; e.Type.String()
}

// An UnsupportedValueError is returned by Marshal when attempting
// to encode an unsupported value.
type UnsupportedValueError struct {
	Value reflect.Value
	Str   string
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Error.png" alt="Control flow graph of Error">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *UnsupportedValueError) Error() string {
	return &#34;json: unsupported value: &#34; &#43; e.Str
}

// Before Go 1.2, an InvalidUTF8Error was returned by Marshal when
// attempting to encode a string value with invalid UTF-8 sequences.
// As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by
// replacing invalid bytes with the Unicode replacement rune U&#43;FFFD.
//
// Deprecated: No longer used; kept for compatibility.
type InvalidUTF8Error struct {
	S string // the whole string value that caused the error
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Error.png" alt="Control flow graph of Error">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *InvalidUTF8Error) Error() string {
	return &#34;json: invalid UTF-8 in string: &#34; &#43; strconv.Quote(e.S)
}

// A MarshalerError represents an error from calling a MarshalJSON or MarshalText method.
type MarshalerError struct {
	Type       reflect.Type
	Err        error
	sourceFunc string
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Error.png" alt="Control flow graph of Error">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *MarshalerError) Error() string {
	srcFunc := e.sourceFunc
	if srcFunc == &#34;&#34; {
		srcFunc = &#34;MarshalJSON&#34;
	}
	return &#34;json: error calling &#34; &#43; srcFunc &#43;
		&#34; for type &#34; &#43; e.Type.String() &#43;
		&#34;: &#34; &#43; e.Err.Error()
}

// Unwrap returns the underlying error.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Error.png" alt="Control flow graph of Error">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *MarshalerError) Unwrap() error { return e.Err }

var hex = &#34;0123456789abcdef&#34;

// An encodeState encodes JSON into a bytes.Buffer.
type encodeState struct {
	bytes.Buffer // accumulated output
	scratch      [64]byte

	// Keep track of what pointers we&#39;ve seen in the current recursive call
	// path, to avoid cycles that could lead to a stack overflow. Only do
	// the relatively expensive map operations if ptrLevel is larger than
	// startDetectingCyclesAfter, so that we skip the work if we&#39;re within a
	// reasonable amount of nested pointers deep.
	ptrLevel uint
	ptrSeen  map[any]struct{}
}

const startDetectingCyclesAfter = 1000

var encodeStatePool sync.Pool

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Unwrap.png" alt="Control flow graph of Unwrap">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newEncodeState() *encodeState {
	if v := encodeStatePool.Get(); v != nil {
		e := v.(*encodeState)
		e.Reset()
		if len(e.ptrSeen) &gt; 0 {
			panic(&#34;ptrEncoder.encode should have emptied ptrSeen via defers&#34;)
		}
		e.ptrLevel = 0
		return e
	}
	return &amp;encodeState{ptrSeen: make(map[any]struct{})}
}

// jsonError is an error wrapper type for internal use only.
// Panics with errors are wrapped in jsonError so that the top-level recover
// can distinguish intentional panics from this package.
type jsonError struct{ error }

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.newEncodeState.png" alt="Control flow graph of newEncodeState">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *encodeState) marshal(v any, opts encOpts) (err error) {
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.marshal.png" alt="Control flow graph of marshal">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>	defer func() {
		if r := recover(); r != nil {
			if je, ok := r.(jsonError); ok {
				err = je.error
			} else {
				panic(r)
			}
		}
	}()
	e.reflectValue(reflect.ValueOf(v), opts)
	return nil
}

// error aborts the encoding by panicking with err wrapped in jsonError.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.marshal$1.png" alt="Control flow graph of marshal$1">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *encodeState) error(err error) {
	panic(jsonError{err})
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.error.png" alt="Control flow graph of error">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func isEmptyValue(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
		return v.Len() == 0
	case reflect.Bool:
		return !v.Bool()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int() == 0
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint() == 0
	case reflect.Float32, reflect.Float64:
		return v.Float() == 0
	case reflect.Interface, reflect.Pointer:
		return v.IsNil()
	}
	return false
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.isEmptyValue.png" alt="Control flow graph of isEmptyValue">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *encodeState) reflectValue(v reflect.Value, opts encOpts) {
	valueEncoder(v)(e, v, opts)
}

type encOpts struct {
	// quoted causes primitive fields to be encoded inside JSON strings.
	quoted bool
	// escapeHTML causes &#39;&lt;&#39;, &#39;&gt;&#39;, and &#39;&amp;&#39; to be escaped in JSON strings.
	escapeHTML bool
}

type encoderFunc func(e *encodeState, v reflect.Value, opts encOpts)

var encoderCache sync.Map // map[reflect.Type]encoderFunc

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.reflectValue.png" alt="Control flow graph of reflectValue">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func valueEncoder(v reflect.Value) encoderFunc {
	if !v.IsValid() {
		return invalidValueEncoder
	}
	return typeEncoder(v.Type())
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.valueEncoder.png" alt="Control flow graph of valueEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func typeEncoder(t reflect.Type) encoderFunc {
	if fi, ok := encoderCache.Load(t); ok {
		return fi.(encoderFunc)
	}

	// To deal with recursive types, populate the map with an
	// indirect func before we build it. This type waits on the
	// real func (f) to be ready and then calls it. This indirect
	// func is only used for recursive types.
	var (
		wg sync.WaitGroup
		f  encoderFunc
	)
	wg.Add(1)
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.typeEncoder.png" alt="Control flow graph of typeEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>	fi, loaded := encoderCache.LoadOrStore(t, encoderFunc(func(e *encodeState, v reflect.Value, opts encOpts) {
		wg.Wait()
		f(e, v, opts)
	}))
	if loaded {
		return fi.(encoderFunc)
	}

	// Compute the real encoder and replace the indirect func with it.
	f = newTypeEncoder(t, true)
	wg.Done()
	encoderCache.Store(t, f)
	return f
}

var (
	marshalerType     = reflect.TypeOf((*Marshaler)(nil)).Elem()
	textMarshalerType = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
)

// newTypeEncoder constructs an encoderFunc for a type.
// The returned encoder only checks CanAddr when allowAddr is true.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.typeEncoder$1.png" alt="Control flow graph of typeEncoder$1">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {
	// If we have a non-pointer value whose type implements
	// Marshaler with a value receiver, then we&#39;re better off taking
	// the address of the value - otherwise we end up with an
	// allocation as we cast the value to an interface.
	if t.Kind() != reflect.Pointer &amp;&amp; allowAddr &amp;&amp; reflect.PointerTo(t).Implements(marshalerType) {
		return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))
	}
	if t.Implements(marshalerType) {
		return marshalerEncoder
	}
	if t.Kind() != reflect.Pointer &amp;&amp; allowAddr &amp;&amp; reflect.PointerTo(t).Implements(textMarshalerType) {
		return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))
	}
	if t.Implements(textMarshalerType) {
		return textMarshalerEncoder
	}

	switch t.Kind() {
	case reflect.Bool:
		return boolEncoder
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return intEncoder
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return uintEncoder
	case reflect.Float32:
		return float32Encoder
	case reflect.Float64:
		return float64Encoder
	case reflect.String:
		return stringEncoder
	case reflect.Interface:
		return interfaceEncoder
	case reflect.Struct:
		return newStructEncoder(t)
	case reflect.Map:
		return newMapEncoder(t)
	case reflect.Slice:
		return newSliceEncoder(t)
	case reflect.Array:
		return newArrayEncoder(t)
	case reflect.Pointer:
		return newPtrEncoder(t)
	default:
		return unsupportedTypeEncoder
	}
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.newTypeEncoder.png" alt="Control flow graph of newTypeEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func invalidValueEncoder(e *encodeState, v reflect.Value, _ encOpts) {
	e.WriteString(&#34;null&#34;)
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.invalidValueEncoder.png" alt="Control flow graph of invalidValueEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func marshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Kind() == reflect.Pointer &amp;&amp; v.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	m, ok := v.Interface().(Marshaler)
	if !ok {
		e.WriteString(&#34;null&#34;)
		return
	}
	b, err := m.MarshalJSON()
	if err == nil {
		// copy JSON into buffer, checking validity.
		err = compact(&amp;e.Buffer, b, opts.escapeHTML)
	}
	if err != nil {
		e.error(&amp;MarshalerError{v.Type(), err, &#34;MarshalJSON&#34;})
	}
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.marshalerEncoder.png" alt="Control flow graph of marshalerEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func addrMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	va := v.Addr()
	if va.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	m := va.Interface().(Marshaler)
	b, err := m.MarshalJSON()
	if err == nil {
		// copy JSON into buffer, checking validity.
		err = compact(&amp;e.Buffer, b, opts.escapeHTML)
	}
	if err != nil {
		e.error(&amp;MarshalerError{v.Type(), err, &#34;MarshalJSON&#34;})
	}
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.addrMarshalerEncoder.png" alt="Control flow graph of addrMarshalerEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func textMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Kind() == reflect.Pointer &amp;&amp; v.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	m, ok := v.Interface().(encoding.TextMarshaler)
	if !ok {
		e.WriteString(&#34;null&#34;)
		return
	}
	b, err := m.MarshalText()
	if err != nil {
		e.error(&amp;MarshalerError{v.Type(), err, &#34;MarshalText&#34;})
	}
	e.stringBytes(b, opts.escapeHTML)
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.textMarshalerEncoder.png" alt="Control flow graph of textMarshalerEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func addrTextMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	va := v.Addr()
	if va.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	m := va.Interface().(encoding.TextMarshaler)
	b, err := m.MarshalText()
	if err != nil {
		e.error(&amp;MarshalerError{v.Type(), err, &#34;MarshalText&#34;})
	}
	e.stringBytes(b, opts.escapeHTML)
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.addrTextMarshalerEncoder.png" alt="Control flow graph of addrTextMarshalerEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func boolEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if opts.quoted {
		e.WriteByte(&#39;&#34;&#39;)
	}
	if v.Bool() {
		e.WriteString(&#34;true&#34;)
	} else {
		e.WriteString(&#34;false&#34;)
	}
	if opts.quoted {
		e.WriteByte(&#39;&#34;&#39;)
	}
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.boolEncoder.png" alt="Control flow graph of boolEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func intEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	b := strconv.AppendInt(e.scratch[:0], v.Int(), 10)
	if opts.quoted {
		e.WriteByte(&#39;&#34;&#39;)
	}
	e.Write(b)
	if opts.quoted {
		e.WriteByte(&#39;&#34;&#39;)
	}
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.intEncoder.png" alt="Control flow graph of intEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func uintEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	b := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)
	if opts.quoted {
		e.WriteByte(&#39;&#34;&#39;)
	}
	e.Write(b)
	if opts.quoted {
		e.WriteByte(&#39;&#34;&#39;)
	}
}

type floatEncoder int // number of bits

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.uintEncoder.png" alt="Control flow graph of uintEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (bits floatEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	f := v.Float()
	if math.IsInf(f, 0) || math.IsNaN(f) {
		e.error(&amp;UnsupportedValueError{v, strconv.FormatFloat(f, &#39;g&#39;, -1, int(bits))})
	}

	// Convert as if by ES6 number to string conversion.
	// This matches most other JSON generators.
	// See golang.org/issue/6384 and golang.org/issue/14135.
	// Like fmt %g, but the exponent cutoffs are different
	// and exponents themselves are not padded to two digits.
	b := e.scratch[:0]
	abs := math.Abs(f)
	fmt := byte(&#39;f&#39;)
	// Note: Must use float32 comparisons for underlying float32 value to get precise cutoffs right.
	if abs != 0 {
		if bits == 64 &amp;&amp; (abs &lt; 1e-6 || abs &gt;= 1e21) || bits == 32 &amp;&amp; (float32(abs) &lt; 1e-6 || float32(abs) &gt;= 1e21) {
			fmt = &#39;e&#39;
		}
	}
	b = strconv.AppendFloat(b, f, fmt, -1, int(bits))
	if fmt == &#39;e&#39; {
		// clean up e-09 to e-9
		n := len(b)
		if n &gt;= 4 &amp;&amp; b[n-4] == &#39;e&#39; &amp;&amp; b[n-3] == &#39;-&#39; &amp;&amp; b[n-2] == &#39;0&#39; {
			b[n-2] = b[n-1]
			b = b[:n-1]
		}
	}

	if opts.quoted {
		e.WriteByte(&#39;&#34;&#39;)
	}
	e.Write(b)
	if opts.quoted {
		e.WriteByte(&#39;&#34;&#39;)
	}
}

var (
	float32Encoder = (floatEncoder(32)).encode
	float64Encoder = (floatEncoder(64)).encode
)

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encode.png" alt="Control flow graph of encode">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func stringEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.Type() == numberType {
		numStr := v.String()
		// In Go1.5 the empty string encodes to &#34;0&#34;, while this is not a valid number literal
		// we keep compatibility so check validity after this.
		if numStr == &#34;&#34; {
			numStr = &#34;0&#34; // Number&#39;s zero-val
		}
		if !isValidNumber(numStr) {
			e.error(fmt.Errorf(&#34;json: invalid number literal %q&#34;, numStr))
		}
		if opts.quoted {
			e.WriteByte(&#39;&#34;&#39;)
		}
		e.WriteString(numStr)
		if opts.quoted {
			e.WriteByte(&#39;&#34;&#39;)
		}
		return
	}
	if opts.quoted {
		e2 := newEncodeState()
		// Since we encode the string twice, we only need to escape HTML
		// the first time.
		e2.string(v.String(), opts.escapeHTML)
		e.stringBytes(e2.Bytes(), false)
		encodeStatePool.Put(e2)
	} else {
		e.string(v.String(), opts.escapeHTML)
	}
}

// isValidNumber reports whether s is a valid JSON number literal.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.stringEncoder.png" alt="Control flow graph of stringEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func isValidNumber(s string) bool {
	// This function implements the JSON numbers grammar.
	// See https://tools.ietf.org/html/rfc7159#section-6
	// and https://www.json.org/img/number.png

	if s == &#34;&#34; {
		return false
	}

	// Optional -
	if s[0] == &#39;-&#39; {
		s = s[1:]
		if s == &#34;&#34; {
			return false
		}
	}

	// Digits
	switch {
	default:
		return false

	case s[0] == &#39;0&#39;:
		s = s[1:]

	case &#39;1&#39; &lt;= s[0] &amp;&amp; s[0] &lt;= &#39;9&#39;:
		s = s[1:]
		for len(s) &gt; 0 &amp;&amp; &#39;0&#39; &lt;= s[0] &amp;&amp; s[0] &lt;= &#39;9&#39; {
			s = s[1:]
		}
	}

	// . followed by 1 or more digits.
	if len(s) &gt;= 2 &amp;&amp; s[0] == &#39;.&#39; &amp;&amp; &#39;0&#39; &lt;= s[1] &amp;&amp; s[1] &lt;= &#39;9&#39; {
		s = s[2:]
		for len(s) &gt; 0 &amp;&amp; &#39;0&#39; &lt;= s[0] &amp;&amp; s[0] &lt;= &#39;9&#39; {
			s = s[1:]
		}
	}

	// e or E followed by an optional - or &#43; and
	// 1 or more digits.
	if len(s) &gt;= 2 &amp;&amp; (s[0] == &#39;e&#39; || s[0] == &#39;E&#39;) {
		s = s[1:]
		if s[0] == &#39;&#43;&#39; || s[0] == &#39;-&#39; {
			s = s[1:]
			if s == &#34;&#34; {
				return false
			}
		}
		for len(s) &gt; 0 &amp;&amp; &#39;0&#39; &lt;= s[0] &amp;&amp; s[0] &lt;= &#39;9&#39; {
			s = s[1:]
		}
	}

	// Make sure we are at the end.
	return s == &#34;&#34;
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.isValidNumber.png" alt="Control flow graph of isValidNumber">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func interfaceEncoder(e *encodeState, v reflect.Value, opts encOpts) {
	if v.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	e.reflectValue(v.Elem(), opts)
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.interfaceEncoder.png" alt="Control flow graph of interfaceEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func unsupportedTypeEncoder(e *encodeState, v reflect.Value, _ encOpts) {
	e.error(&amp;UnsupportedTypeError{v.Type()})
}

type structEncoder struct {
	fields structFields
}

type structFields struct {
	list      []field
	nameIndex map[string]int
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.unsupportedTypeEncoder.png" alt="Control flow graph of unsupportedTypeEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (se structEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	next := byte(&#39;{&#39;)
FieldLoop:
	for i := range se.fields.list {
		f := &amp;se.fields.list[i]

		// Find the nested struct field by following f.index.
		fv := v
		for _, i := range f.index {
			if fv.Kind() == reflect.Pointer {
				if fv.IsNil() {
					continue FieldLoop
				}
				fv = fv.Elem()
			}
			fv = fv.Field(i)
		}

		if f.omitEmpty &amp;&amp; isEmptyValue(fv) {
			continue
		}
		e.WriteByte(next)
		next = &#39;,&#39;
		if opts.escapeHTML {
			e.WriteString(f.nameEscHTML)
		} else {
			e.WriteString(f.nameNonEsc)
		}
		opts.quoted = f.quoted
		f.encoder(e, fv, opts)
	}
	if next == &#39;{&#39; {
		e.WriteString(&#34;{}&#34;)
	} else {
		e.WriteByte(&#39;}&#39;)
	}
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encode.png" alt="Control flow graph of encode">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newStructEncoder(t reflect.Type) encoderFunc {
	se := structEncoder{fields: cachedTypeFields(t)}
	return se.encode
}

type mapEncoder struct {
	elemEnc encoderFunc
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.newStructEncoder.png" alt="Control flow graph of newStructEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (me mapEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	if v.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	if e.ptrLevel&#43;&#43;; e.ptrLevel &gt; startDetectingCyclesAfter {
		// We&#39;re a large number of nested ptrEncoder.encode calls deep;
		// start checking if we&#39;ve run into a pointer cycle.
		ptr := v.Pointer()
		if _, ok := e.ptrSeen[ptr]; ok {
			e.error(&amp;UnsupportedValueError{v, fmt.Sprintf(&#34;encountered a cycle via %s&#34;, v.Type())})
		}
		e.ptrSeen[ptr] = struct{}{}
		defer delete(e.ptrSeen, ptr)
	}
	e.WriteByte(&#39;{&#39;)

	// Extract and sort the keys.
	sv := make([]reflectWithString, v.Len())
	mi := v.MapRange()
	for i := 0; mi.Next(); i&#43;&#43; {
		sv[i].k = mi.Key()
		sv[i].v = mi.Value()
		if err := sv[i].resolve(); err != nil {
			e.error(fmt.Errorf(&#34;json: encoding error for type %q: %q&#34;, v.Type().String(), err.Error()))
		}
	}
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encode.png" alt="Control flow graph of encode">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>	sort.Slice(sv, func(i, j int) bool { return sv[i].ks &lt; sv[j].ks })

	for i, kv := range sv {
		if i &gt; 0 {
			e.WriteByte(&#39;,&#39;)
		}
		e.string(kv.ks, opts.escapeHTML)
		e.WriteByte(&#39;:&#39;)
		me.elemEnc(e, kv.v, opts)
	}
	e.WriteByte(&#39;}&#39;)
	e.ptrLevel--
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encode$1.png" alt="Control flow graph of encode$1">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newMapEncoder(t reflect.Type) encoderFunc {
	switch t.Key().Kind() {
	case reflect.String,
		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
	default:
		if !t.Key().Implements(textMarshalerType) {
			return unsupportedTypeEncoder
		}
	}
	me := mapEncoder{typeEncoder(t.Elem())}
	return me.encode
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.newMapEncoder.png" alt="Control flow graph of newMapEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func encodeByteSlice(e *encodeState, v reflect.Value, _ encOpts) {
	if v.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	s := v.Bytes()
	e.WriteByte(&#39;&#34;&#39;)
	encodedLen := base64.StdEncoding.EncodedLen(len(s))
	if encodedLen &lt;= len(e.scratch) {
		// If the encoded bytes fit in e.scratch, avoid an extra
		// allocation and use the cheaper Encoding.Encode.
		dst := e.scratch[:encodedLen]
		base64.StdEncoding.Encode(dst, s)
		e.Write(dst)
	} else if encodedLen &lt;= 1024 {
		// The encoded bytes are short enough to allocate for, and
		// Encoding.Encode is still cheaper.
		dst := make([]byte, encodedLen)
		base64.StdEncoding.Encode(dst, s)
		e.Write(dst)
	} else {
		// The encoded bytes are too long to cheaply allocate, and
		// Encoding.Encode is no longer noticeably cheaper.
		enc := base64.NewEncoder(base64.StdEncoding, e)
		enc.Write(s)
		enc.Close()
	}
	e.WriteByte(&#39;&#34;&#39;)
}

// sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn&#39;t nil.
type sliceEncoder struct {
	arrayEnc encoderFunc
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encodeByteSlice.png" alt="Control flow graph of encodeByteSlice">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (se sliceEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	if v.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	if e.ptrLevel&#43;&#43;; e.ptrLevel &gt; startDetectingCyclesAfter {
		// We&#39;re a large number of nested ptrEncoder.encode calls deep;
		// start checking if we&#39;ve run into a pointer cycle.
		// Here we use a struct to memorize the pointer to the first element of the slice
		// and its length.
		ptr := struct {
			ptr uintptr
			len int
		}{v.Pointer(), v.Len()}
		if _, ok := e.ptrSeen[ptr]; ok {
			e.error(&amp;UnsupportedValueError{v, fmt.Sprintf(&#34;encountered a cycle via %s&#34;, v.Type())})
		}
		e.ptrSeen[ptr] = struct{}{}
		defer delete(e.ptrSeen, ptr)
	}
	se.arrayEnc(e, v, opts)
	e.ptrLevel--
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encode.png" alt="Control flow graph of encode">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newSliceEncoder(t reflect.Type) encoderFunc {
	// Byte slices get special treatment; arrays don&#39;t.
	if t.Elem().Kind() == reflect.Uint8 {
		p := reflect.PointerTo(t.Elem())
		if !p.Implements(marshalerType) &amp;&amp; !p.Implements(textMarshalerType) {
			return encodeByteSlice
		}
	}
	enc := sliceEncoder{newArrayEncoder(t)}
	return enc.encode
}

type arrayEncoder struct {
	elemEnc encoderFunc
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.newSliceEncoder.png" alt="Control flow graph of newSliceEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (ae arrayEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	e.WriteByte(&#39;[&#39;)
	n := v.Len()
	for i := 0; i &lt; n; i&#43;&#43; {
		if i &gt; 0 {
			e.WriteByte(&#39;,&#39;)
		}
		ae.elemEnc(e, v.Index(i), opts)
	}
	e.WriteByte(&#39;]&#39;)
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encode.png" alt="Control flow graph of encode">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newArrayEncoder(t reflect.Type) encoderFunc {
	enc := arrayEncoder{typeEncoder(t.Elem())}
	return enc.encode
}

type ptrEncoder struct {
	elemEnc encoderFunc
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.newArrayEncoder.png" alt="Control flow graph of newArrayEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (pe ptrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	if v.IsNil() {
		e.WriteString(&#34;null&#34;)
		return
	}
	if e.ptrLevel&#43;&#43;; e.ptrLevel &gt; startDetectingCyclesAfter {
		// We&#39;re a large number of nested ptrEncoder.encode calls deep;
		// start checking if we&#39;ve run into a pointer cycle.
		ptr := v.Interface()
		if _, ok := e.ptrSeen[ptr]; ok {
			e.error(&amp;UnsupportedValueError{v, fmt.Sprintf(&#34;encountered a cycle via %s&#34;, v.Type())})
		}
		e.ptrSeen[ptr] = struct{}{}
		defer delete(e.ptrSeen, ptr)
	}
	pe.elemEnc(e, v.Elem(), opts)
	e.ptrLevel--
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encode.png" alt="Control flow graph of encode">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newPtrEncoder(t reflect.Type) encoderFunc {
	enc := ptrEncoder{typeEncoder(t.Elem())}
	return enc.encode
}

type condAddrEncoder struct {
	canAddrEnc, elseEnc encoderFunc
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.newPtrEncoder.png" alt="Control flow graph of newPtrEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (ce condAddrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
	if v.CanAddr() {
		ce.canAddrEnc(e, v, opts)
	} else {
		ce.elseEnc(e, v, opts)
	}
}

// newCondAddrEncoder returns an encoder that checks whether its value
// CanAddr and delegates to canAddrEnc if so, else to elseEnc.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.encode.png" alt="Control flow graph of encode">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newCondAddrEncoder(canAddrEnc, elseEnc encoderFunc) encoderFunc {
	enc := condAddrEncoder{canAddrEnc: canAddrEnc, elseEnc: elseEnc}
	return enc.encode
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.newCondAddrEncoder.png" alt="Control flow graph of newCondAddrEncoder">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func isValidTag(s string) bool {
	if s == &#34;&#34; {
		return false
	}
	for _, c := range s {
		switch {
		case strings.ContainsRune(&#34;!#$%&amp;()*&#43;-./:;&lt;=&gt;?@[]^_{|}~ &#34;, c):
			// Backslash and quote chars are reserved, but
			// otherwise any punctuation chars are allowed
			// in a tag name.
		case !unicode.IsLetter(c) &amp;&amp; !unicode.IsDigit(c):
			return false
		}
	}
	return true
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.isValidTag.png" alt="Control flow graph of isValidTag">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func typeByIndex(t reflect.Type, index []int) reflect.Type {
	for _, i := range index {
		if t.Kind() == reflect.Pointer {
			t = t.Elem()
		}
		t = t.Field(i).Type
	}
	return t
}

type reflectWithString struct {
	k  reflect.Value
	v  reflect.Value
	ks string
}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.typeByIndex.png" alt="Control flow graph of typeByIndex">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (w *reflectWithString) resolve() error {
	if w.k.Kind() == reflect.String {
		w.ks = w.k.String()
		return nil
	}
	if tm, ok := w.k.Interface().(encoding.TextMarshaler); ok {
		if w.k.Kind() == reflect.Pointer &amp;&amp; w.k.IsNil() {
			return nil
		}
		buf, err := tm.MarshalText()
		w.ks = string(buf)
		return err
	}
	switch w.k.Kind() {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		w.ks = strconv.FormatInt(w.k.Int(), 10)
		return nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		w.ks = strconv.FormatUint(w.k.Uint(), 10)
		return nil
	}
	panic(&#34;unexpected map key type&#34;)
}

// NOTE: keep in sync with stringBytes below.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.resolve.png" alt="Control flow graph of resolve">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *encodeState) string(s string, escapeHTML bool) {
	e.WriteByte(&#39;&#34;&#39;)
	start := 0
	for i := 0; i &lt; len(s); {
		if b := s[i]; b &lt; utf8.RuneSelf {
			if htmlSafeSet[b] || (!escapeHTML &amp;&amp; safeSet[b]) {
				i&#43;&#43;
				continue
			}
			if start &lt; i {
				e.WriteString(s[start:i])
			}
			e.WriteByte(&#39;\\&#39;)
			switch b {
			case &#39;\\&#39;, &#39;&#34;&#39;:
				e.WriteByte(b)
			case &#39;\n&#39;:
				e.WriteByte(&#39;n&#39;)
			case &#39;\r&#39;:
				e.WriteByte(&#39;r&#39;)
			case &#39;\t&#39;:
				e.WriteByte(&#39;t&#39;)
			default:
				// This encodes bytes &lt; 0x20 except for \t, \n and \r.
				// If escapeHTML is set, it also escapes &lt;, &gt;, and &amp;
				// because they can lead to security holes when
				// user-controlled strings are rendered into JSON
				// and served to some browsers.
				e.WriteString(`u00`)
				e.WriteByte(hex[b&gt;&gt;4])
				e.WriteByte(hex[b&amp;0xF])
			}
			i&#43;&#43;
			start = i
			continue
		}
		c, size := utf8.DecodeRuneInString(s[i:])
		if c == utf8.RuneError &amp;&amp; size == 1 {
			if start &lt; i {
				e.WriteString(s[start:i])
			}
			e.WriteString(`\ufffd`)
			i &#43;= size
			start = i
			continue
		}
		// U&#43;2028 is LINE SEPARATOR.
		// U&#43;2029 is PARAGRAPH SEPARATOR.
		// They are both technically valid characters in JSON strings,
		// but don&#39;t work in JSONP, which has to be evaluated as JavaScript,
		// and can lead to security holes there. It is valid JSON to
		// escape them, so we do so unconditionally.
		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
		if c == &#39;\u2028&#39; || c == &#39;\u2029&#39; {
			if start &lt; i {
				e.WriteString(s[start:i])
			}
			e.WriteString(`\u202`)
			e.WriteByte(hex[c&amp;0xF])
			i &#43;= size
			start = i
			continue
		}
		i &#43;= size
	}
	if start &lt; len(s) {
		e.WriteString(s[start:])
	}
	e.WriteByte(&#39;&#34;&#39;)
}

// NOTE: keep in sync with string above.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.string.png" alt="Control flow graph of string">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *encodeState) stringBytes(s []byte, escapeHTML bool) {
	e.WriteByte(&#39;&#34;&#39;)
	start := 0
	for i := 0; i &lt; len(s); {
		if b := s[i]; b &lt; utf8.RuneSelf {
			if htmlSafeSet[b] || (!escapeHTML &amp;&amp; safeSet[b]) {
				i&#43;&#43;
				continue
			}
			if start &lt; i {
				e.Write(s[start:i])
			}
			e.WriteByte(&#39;\\&#39;)
			switch b {
			case &#39;\\&#39;, &#39;&#34;&#39;:
				e.WriteByte(b)
			case &#39;\n&#39;:
				e.WriteByte(&#39;n&#39;)
			case &#39;\r&#39;:
				e.WriteByte(&#39;r&#39;)
			case &#39;\t&#39;:
				e.WriteByte(&#39;t&#39;)
			default:
				// This encodes bytes &lt; 0x20 except for \t, \n and \r.
				// If escapeHTML is set, it also escapes &lt;, &gt;, and &amp;
				// because they can lead to security holes when
				// user-controlled strings are rendered into JSON
				// and served to some browsers.
				e.WriteString(`u00`)
				e.WriteByte(hex[b&gt;&gt;4])
				e.WriteByte(hex[b&amp;0xF])
			}
			i&#43;&#43;
			start = i
			continue
		}
		c, size := utf8.DecodeRune(s[i:])
		if c == utf8.RuneError &amp;&amp; size == 1 {
			if start &lt; i {
				e.Write(s[start:i])
			}
			e.WriteString(`\ufffd`)
			i &#43;= size
			start = i
			continue
		}
		// U&#43;2028 is LINE SEPARATOR.
		// U&#43;2029 is PARAGRAPH SEPARATOR.
		// They are both technically valid characters in JSON strings,
		// but don&#39;t work in JSONP, which has to be evaluated as JavaScript,
		// and can lead to security holes there. It is valid JSON to
		// escape them, so we do so unconditionally.
		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
		if c == &#39;\u2028&#39; || c == &#39;\u2029&#39; {
			if start &lt; i {
				e.Write(s[start:i])
			}
			e.WriteString(`\u202`)
			e.WriteByte(hex[c&amp;0xF])
			i &#43;= size
			start = i
			continue
		}
		i &#43;= size
	}
	if start &lt; len(s) {
		e.Write(s[start:])
	}
	e.WriteByte(&#39;&#34;&#39;)
}

// A field represents a single field found in a struct.
type field struct {
	name      string
	nameBytes []byte                 // []byte(name)
	equalFold func(s, t []byte) bool // bytes.EqualFold or equivalent

	nameNonEsc  string // `&#34;` &#43; name &#43; `&#34;:`
	nameEscHTML string // `&#34;` &#43; HTMLEscape(name) &#43; `&#34;:`

	tag       bool
	index     []int
	typ       reflect.Type
	omitEmpty bool
	quoted    bool

	encoder encoderFunc
}

// byIndex sorts field by index sequence.
type byIndex []field

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.stringBytes.png" alt="Control flow graph of stringBytes">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (x byIndex) Len() int { return len(x) }

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Len.png" alt="Control flow graph of Len">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (x byIndex) Swap(i, j int) { x[i], x[j] = x[j], x[i] }

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Swap.png" alt="Control flow graph of Swap">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (x byIndex) Less(i, j int) bool {
	for k, xik := range x[i].index {
		if k &gt;= len(x[j].index) {
			return false
		}
		if xik != x[j].index[k] {
			return xik &lt; x[j].index[k]
		}
	}
	return len(x[i].index) &lt; len(x[j].index)
}

// typeFields returns a list of fields that JSON should recognize for the given type.
// The algorithm is breadth-first search over the set of structs to include - the top struct
// and then any reachable anonymous structs.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.Less.png" alt="Control flow graph of Less">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func typeFields(t reflect.Type) structFields {
	// Anonymous fields to explore at the current level and the next.
	current := []field{}
	next := []field{{typ: t}}

	// Count of queued names for current level and the next.
	var count, nextCount map[reflect.Type]int

	// Types already visited at an earlier level.
	visited := map[reflect.Type]bool{}

	// Fields found.
	var fields []field

	// Buffer to run HTMLEscape on field names.
	var nameEscBuf bytes.Buffer

	for len(next) &gt; 0 {
		current, next = next, current[:0]
		count, nextCount = nextCount, map[reflect.Type]int{}

		for _, f := range current {
			if visited[f.typ] {
				continue
			}
			visited[f.typ] = true

			// Scan f.typ for fields to include.
			for i := 0; i &lt; f.typ.NumField(); i&#43;&#43; {
				sf := f.typ.Field(i)
				if sf.Anonymous {
					t := sf.Type
					if t.Kind() == reflect.Pointer {
						t = t.Elem()
					}
					if !sf.IsExported() &amp;&amp; t.Kind() != reflect.Struct {
						// Ignore embedded fields of unexported non-struct types.
						continue
					}
					// Do not ignore embedded fields of unexported struct types
					// since they may have exported fields.
				} else if !sf.IsExported() {
					// Ignore unexported non-embedded fields.
					continue
				}
				tag := sf.Tag.Get(&#34;json&#34;)
				if tag == &#34;-&#34; {
					continue
				}
				name, opts := parseTag(tag)
				if !isValidTag(name) {
					name = &#34;&#34;
				}
				index := make([]int, len(f.index)&#43;1)
				copy(index, f.index)
				index[len(f.index)] = i

				ft := sf.Type
				if ft.Name() == &#34;&#34; &amp;&amp; ft.Kind() == reflect.Pointer {
					// Follow pointer.
					ft = ft.Elem()
				}

				// Only strings, floats, integers, and booleans can be quoted.
				quoted := false
				if opts.Contains(&#34;string&#34;) {
					switch ft.Kind() {
					case reflect.Bool,
						reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
						reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
						reflect.Float32, reflect.Float64,
						reflect.String:
						quoted = true
					}
				}

				// Record found field and index sequence.
				if name != &#34;&#34; || !sf.Anonymous || ft.Kind() != reflect.Struct {
					tagged := name != &#34;&#34;
					if name == &#34;&#34; {
						name = sf.Name
					}
					field := field{
						name:      name,
						tag:       tagged,
						index:     index,
						typ:       ft,
						omitEmpty: opts.Contains(&#34;omitempty&#34;),
						quoted:    quoted,
					}
					field.nameBytes = []byte(field.name)
					field.equalFold = foldFunc(field.nameBytes)

					// Build nameEscHTML and nameNonEsc ahead of time.
					nameEscBuf.Reset()
					nameEscBuf.WriteString(`&#34;`)
					HTMLEscape(&amp;nameEscBuf, field.nameBytes)
					nameEscBuf.WriteString(`&#34;:`)
					field.nameEscHTML = nameEscBuf.String()
					field.nameNonEsc = `&#34;` &#43; field.name &#43; `&#34;:`

					fields = append(fields, field)
					if count[f.typ] &gt; 1 {
						// If there were multiple instances, add a second,
						// so that the annihilation code will see a duplicate.
						// It only cares about the distinction between 1 or 2,
						// so don&#39;t bother generating any more copies.
						fields = append(fields, fields[len(fields)-1])
					}
					continue
				}

				// Record new anonymous struct to explore in next round.
				nextCount[ft]&#43;&#43;
				if nextCount[ft] == 1 {
					next = append(next, field{name: ft.Name(), index: index, typ: ft})
				}
			}
		}
	}

</pre>
            </td>
            <td>
                
                    <img src="encode.go._.typeFields.png" alt="Control flow graph of typeFields">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>	sort.Slice(fields, func(i, j int) bool {
		x := fields
		// sort field by name, breaking ties with depth, then
		// breaking ties with &#34;name came from json tag&#34;, then
		// breaking ties with index sequence.
		if x[i].name != x[j].name {
			return x[i].name &lt; x[j].name
		}
		if len(x[i].index) != len(x[j].index) {
			return len(x[i].index) &lt; len(x[j].index)
		}
		if x[i].tag != x[j].tag {
			return x[i].tag
		}
		return byIndex(x).Less(i, j)
	})

	// Delete all fields that are hidden by the Go rules for embedded fields,
	// except that fields with JSON tags are promoted.

	// The fields are sorted in primary order of name, secondary order
	// of field index length. Loop over names; for each name, delete
	// hidden fields by choosing the one dominant field that survives.
	out := fields[:0]
	for advance, i := 0, 0; i &lt; len(fields); i &#43;= advance {
		// One iteration per name.
		// Find the sequence of fields with the name of this first field.
		fi := fields[i]
		name := fi.name
		for advance = 1; i&#43;advance &lt; len(fields); advance&#43;&#43; {
			fj := fields[i&#43;advance]
			if fj.name != name {
				break
			}
		}
		if advance == 1 { // Only one field with this name
			out = append(out, fi)
			continue
		}
		dominant, ok := dominantField(fields[i : i&#43;advance])
		if ok {
			out = append(out, dominant)
		}
	}

	fields = out
	sort.Sort(byIndex(fields))

	for i := range fields {
		f := &amp;fields[i]
		f.encoder = typeEncoder(typeByIndex(t, f.index))
	}
	nameIndex := make(map[string]int, len(fields))
	for i, field := range fields {
		nameIndex[field.name] = i
	}
	return structFields{fields, nameIndex}
}

// dominantField looks through the fields, all of which are known to
// have the same name, to find the single field that dominates the
// others using Go&#39;s embedding rules, modified by the presence of
// JSON tags. If there are multiple top-level fields, the boolean
// will be false: This condition is an error in Go and we skip all
// the fields.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.typeFields$1.png" alt="Control flow graph of typeFields$1">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func dominantField(fields []field) (field, bool) {
	// The fields are sorted in increasing index-length order, then by presence of tag.
	// That means that the first field is the dominant one. We need only check
	// for error cases: two fields at top level, either both tagged or neither tagged.
	if len(fields) &gt; 1 &amp;&amp; len(fields[0].index) == len(fields[1].index) &amp;&amp; fields[0].tag == fields[1].tag {
		return field{}, false
	}
	return fields[0], true
}

var fieldCache sync.Map // map[reflect.Type]structFields

// cachedTypeFields is like typeFields but uses a cache to avoid repeated work.
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.dominantField.png" alt="Control flow graph of dominantField">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func cachedTypeFields(t reflect.Type) structFields {
	if f, ok := fieldCache.Load(t); ok {
		return f.(structFields)
	}
	f, _ := fieldCache.LoadOrStore(t, typeFields(t))
	return f.(structFields)
}
</pre>
            </td>
            <td>
                
                    <img src="encode.go._.cachedTypeFields.png" alt="Control flow graph of cachedTypeFields">
                
            </td>
        </tr>
    
</table>
</body>
</html>