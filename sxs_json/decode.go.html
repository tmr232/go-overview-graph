<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>decode.go Graph Overview</title>
    <style>
        td {
            vertical-align: top;
        }

        pre {
            padding-right: 200px;
        }

        td {
            border-top: solid 1px blue;
        }
    </style>
</head>
<body>
<h1>
    File: <code>decode.go</code>
</h1>
<table>
    
        <tr>
            <td>
            <pre>// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Represents JSON data structure using native Go types: booleans, floats,
// strings, arrays, and maps.

package json

import (
	&#34;encoding&#34;
	&#34;encoding/base64&#34;
	&#34;fmt&#34;
	&#34;reflect&#34;
	&#34;strconv&#34;
	&#34;strings&#34;
	&#34;unicode&#34;
	&#34;unicode/utf16&#34;
	&#34;unicode/utf8&#34;
)

// Unmarshal parses the JSON-encoded data and stores the result
// in the value pointed to by v. If v is nil or not a pointer,
// Unmarshal returns an InvalidUnmarshalError.
//
// Unmarshal uses the inverse of the encodings that
// Marshal uses, allocating maps, slices, and pointers as necessary,
// with the following additional rules:
//
// To unmarshal JSON into a pointer, Unmarshal first handles the case of
// the JSON being the JSON literal null. In that case, Unmarshal sets
// the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into
// the value pointed at by the pointer. If the pointer is nil, Unmarshal
// allocates a new value for it to point to.
//
// To unmarshal JSON into a value implementing the Unmarshaler interface,
// Unmarshal calls that value&#39;s UnmarshalJSON method, including
// when the input is a JSON null.
// Otherwise, if the value implements encoding.TextUnmarshaler
// and the input is a JSON quoted string, Unmarshal calls that value&#39;s
// UnmarshalText method with the unquoted form of the string.
//
// To unmarshal JSON into a struct, Unmarshal matches incoming object
// keys to the keys used by Marshal (either the struct field name or its tag),
// preferring an exact match but also accepting a case-insensitive match. By
// default, object keys which don&#39;t have a corresponding struct field are
// ignored (see Decoder.DisallowUnknownFields for an alternative).
//
// To unmarshal JSON into an interface value,
// Unmarshal stores one of these in the interface value:
//
//	bool, for JSON booleans
//	float64, for JSON numbers
//	string, for JSON strings
//	[]interface{}, for JSON arrays
//	map[string]interface{}, for JSON objects
//	nil for JSON null
//
// To unmarshal a JSON array into a slice, Unmarshal resets the slice length
// to zero and then appends each element to the slice.
// As a special case, to unmarshal an empty JSON array into a slice,
// Unmarshal replaces the slice with a new empty slice.
//
// To unmarshal a JSON array into a Go array, Unmarshal decodes
// JSON array elements into corresponding Go array elements.
// If the Go array is smaller than the JSON array,
// the additional JSON array elements are discarded.
// If the JSON array is smaller than the Go array,
// the additional Go array elements are set to zero values.
//
// To unmarshal a JSON object into a map, Unmarshal first establishes a map to
// use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal
// reuses the existing map, keeping existing entries. Unmarshal then stores
// key-value pairs from the JSON object into the map. The map&#39;s key type must
// either be any string type, an integer, implement json.Unmarshaler, or
// implement encoding.TextUnmarshaler.
//
// If a JSON value is not appropriate for a given target type,
// or if a JSON number overflows the target type, Unmarshal
// skips that field and completes the unmarshaling as best it can.
// If no more serious errors are encountered, Unmarshal returns
// an UnmarshalTypeError describing the earliest such error. In any
// case, it&#39;s not guaranteed that all the remaining fields following
// the problematic one will be unmarshaled into the target object.
//
// The JSON null value unmarshals into an interface, map, pointer, or slice
// by setting that Go value to nil. Because null is often used in JSON to mean
// ``not present,&#39;&#39; unmarshaling a JSON null into any other Go type has no effect
// on the value and produces no error.
//
// When unmarshaling quoted strings, invalid UTF-8 or
// invalid UTF-16 surrogate pairs are not treated as an error.
// Instead, they are replaced by the Unicode replacement
// character U&#43;FFFD.
//
</pre>
            </td>
            <td>
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Unmarshal(data []byte, v any) error {
	// Check for well-formedness.
	// Avoids filling out half a data structure
	// before discovering a JSON syntax error.
	var d decodeState
	err := checkValid(data, &amp;d.scan)
	if err != nil {
		return err
	}

	d.init(data)
	return d.unmarshal(v)
}

// Unmarshaler is the interface implemented by types
// that can unmarshal a JSON description of themselves.
// The input can be assumed to be a valid encoding of
// a JSON value. UnmarshalJSON must copy the JSON data
// if it wishes to retain the data after returning.
//
// By convention, to approximate the behavior of Unmarshal itself,
// Unmarshalers implement UnmarshalJSON([]byte(&#34;null&#34;)) as a no-op.
type Unmarshaler interface {
	UnmarshalJSON([]byte) error
}

// An UnmarshalTypeError describes a JSON value that was
// not appropriate for a value of a specific Go type.
type UnmarshalTypeError struct {
	Value  string       // description of JSON value - &#34;bool&#34;, &#34;array&#34;, &#34;number -5&#34;
	Type   reflect.Type // type of Go value it could not be assigned to
	Offset int64        // error occurred after reading Offset bytes
	Struct string       // name of the struct type containing the field
	Field  string       // the full path from root node to the field
}

</pre>
            </td>
            <td>
                
                    <img src="decode.go._.Unmarshal.png" alt="Control flow graph of Unmarshal">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *UnmarshalTypeError) Error() string {
	if e.Struct != &#34;&#34; || e.Field != &#34;&#34; {
		return &#34;json: cannot unmarshal &#34; &#43; e.Value &#43; &#34; into Go struct field &#34; &#43; e.Struct &#43; &#34;.&#34; &#43; e.Field &#43; &#34; of type &#34; &#43; e.Type.String()
	}
	return &#34;json: cannot unmarshal &#34; &#43; e.Value &#43; &#34; into Go value of type &#34; &#43; e.Type.String()
}

// An UnmarshalFieldError describes a JSON object key that
// led to an unexported (and therefore unwritable) struct field.
//
// Deprecated: No longer used; kept for compatibility.
type UnmarshalFieldError struct {
	Key   string
	Type  reflect.Type
	Field reflect.StructField
}

</pre>
            </td>
            <td>
                
                    <img src="decode.go._.Error.png" alt="Control flow graph of Error">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *UnmarshalFieldError) Error() string {
	return &#34;json: cannot unmarshal object key &#34; &#43; strconv.Quote(e.Key) &#43; &#34; into unexported field &#34; &#43; e.Field.Name &#43; &#34; of type &#34; &#43; e.Type.String()
}

// An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
// (The argument to Unmarshal must be a non-nil pointer.)
type InvalidUnmarshalError struct {
	Type reflect.Type
}

</pre>
            </td>
            <td>
                
                    <img src="decode.go._.Error.png" alt="Control flow graph of Error">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (e *InvalidUnmarshalError) Error() string {
	if e.Type == nil {
		return &#34;json: Unmarshal(nil)&#34;
	}

	if e.Type.Kind() != reflect.Pointer {
		return &#34;json: Unmarshal(non-pointer &#34; &#43; e.Type.String() &#43; &#34;)&#34;
	}
	return &#34;json: Unmarshal(nil &#34; &#43; e.Type.String() &#43; &#34;)&#34;
}

</pre>
            </td>
            <td>
                
                    <img src="decode.go._.Error.png" alt="Control flow graph of Error">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) unmarshal(v any) error {
	rv := reflect.ValueOf(v)
	if rv.Kind() != reflect.Pointer || rv.IsNil() {
		return &amp;InvalidUnmarshalError{reflect.TypeOf(v)}
	}

	d.scan.reset()
	d.scanWhile(scanSkipSpace)
	// We decode rv not rv.Elem because the Unmarshaler interface
	// test must be applied at the top level of the value.
	err := d.value(rv)
	if err != nil {
		return d.addErrorContext(err)
	}
	return d.savedError
}

// A Number represents a JSON number literal.
type Number string

// String returns the literal text of the number.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.unmarshal.png" alt="Control flow graph of unmarshal">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (n Number) String() string { return string(n) }

// Float64 returns the number as a float64.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.String.png" alt="Control flow graph of String">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (n Number) Float64() (float64, error) {
	return strconv.ParseFloat(string(n), 64)
}

// Int64 returns the number as an int64.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.Float64.png" alt="Control flow graph of Float64">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (n Number) Int64() (int64, error) {
	return strconv.ParseInt(string(n), 10, 64)
}

// An errorContext provides context for type errors during decoding.
type errorContext struct {
	Struct     reflect.Type
	FieldStack []string
}

// decodeState represents the state while decoding a JSON value.
type decodeState struct {
	data                  []byte
	off                   int // next read offset in data
	opcode                int // last read result
	scan                  scanner
	errorContext          *errorContext
	savedError            error
	useNumber             bool
	disallowUnknownFields bool
}

// readIndex returns the position of the last byte read.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.Int64.png" alt="Control flow graph of Int64">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) readIndex() int {
	return d.off - 1
}

// phasePanicMsg is used as a panic message when we end up with something that
// shouldn&#39;t happen. It can indicate a bug in the JSON decoder, or that
// something is editing the data slice while the decoder executes.
const phasePanicMsg = &#34;JSON decoder out of sync - data changing underfoot?&#34;

</pre>
            </td>
            <td>
                
                    <img src="decode.go._.readIndex.png" alt="Control flow graph of readIndex">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) init(data []byte) *decodeState {
	d.data = data
	d.off = 0
	d.savedError = nil
	if d.errorContext != nil {
		d.errorContext.Struct = nil
		// Reuse the allocated space for the FieldStack slice.
		d.errorContext.FieldStack = d.errorContext.FieldStack[:0]
	}
	return d
}

// saveError saves the first err it is called with,
// for reporting at the end of the unmarshal.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.init.png" alt="Control flow graph of init">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) saveError(err error) {
	if d.savedError == nil {
		d.savedError = d.addErrorContext(err)
	}
}

// addErrorContext returns a new error enhanced with information from d.errorContext
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.saveError.png" alt="Control flow graph of saveError">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) addErrorContext(err error) error {
	if d.errorContext != nil &amp;&amp; (d.errorContext.Struct != nil || len(d.errorContext.FieldStack) &gt; 0) {
		switch err := err.(type) {
		case *UnmarshalTypeError:
			err.Struct = d.errorContext.Struct.Name()
			err.Field = strings.Join(d.errorContext.FieldStack, &#34;.&#34;)
		}
	}
	return err
}

// skip scans to the end of what was started.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.addErrorContext.png" alt="Control flow graph of addErrorContext">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) skip() {
	s, data, i := &amp;d.scan, d.data, d.off
	depth := len(s.parseState)
	for {
		op := s.step(s, data[i])
		i&#43;&#43;
		if len(s.parseState) &lt; depth {
			d.off = i
			d.opcode = op
			return
		}
	}
}

// scanNext processes the byte at d.data[d.off].
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.skip.png" alt="Control flow graph of skip">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) scanNext() {
	if d.off &lt; len(d.data) {
		d.opcode = d.scan.step(&amp;d.scan, d.data[d.off])
		d.off&#43;&#43;
	} else {
		d.opcode = d.scan.eof()
		d.off = len(d.data) &#43; 1 // mark processed EOF with len&#43;1
	}
}

// scanWhile processes bytes in d.data[d.off:] until it
// receives a scan code not equal to op.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.scanNext.png" alt="Control flow graph of scanNext">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) scanWhile(op int) {
	s, data, i := &amp;d.scan, d.data, d.off
	for i &lt; len(data) {
		newOp := s.step(s, data[i])
		i&#43;&#43;
		if newOp != op {
			d.opcode = newOp
			d.off = i
			return
		}
	}

	d.off = len(data) &#43; 1 // mark processed EOF with len&#43;1
	d.opcode = d.scan.eof()
}

// rescanLiteral is similar to scanWhile(scanContinue), but it specialises the
// common case where we&#39;re decoding a literal. The decoder scans the input
// twice, once for syntax errors and to check the length of the value, and the
// second to perform the decoding.
//
// Only in the second step do we use decodeState to tokenize literals, so we
// know there aren&#39;t any syntax errors. We can take advantage of that knowledge,
// and scan a literal&#39;s bytes much more quickly.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.scanWhile.png" alt="Control flow graph of scanWhile">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) rescanLiteral() {
	data, i := d.data, d.off
Switch:
	switch data[i-1] {
	case &#39;&#34;&#39;: // string
		for ; i &lt; len(data); i&#43;&#43; {
			switch data[i] {
			case &#39;\\&#39;:
				i&#43;&#43; // escaped char
			case &#39;&#34;&#39;:
				i&#43;&#43; // tokenize the closing quote too
				break Switch
			}
		}
	case &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;: // number
		for ; i &lt; len(data); i&#43;&#43; {
			switch data[i] {
			case &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
				&#39;.&#39;, &#39;e&#39;, &#39;E&#39;, &#39;&#43;&#39;, &#39;-&#39;:
			default:
				break Switch
			}
		}
	case &#39;t&#39;: // true
		i &#43;= len(&#34;rue&#34;)
	case &#39;f&#39;: // false
		i &#43;= len(&#34;alse&#34;)
	case &#39;n&#39;: // null
		i &#43;= len(&#34;ull&#34;)
	}
	if i &lt; len(data) {
		d.opcode = stateEndValue(&amp;d.scan, data[i])
	} else {
		d.opcode = scanEnd
	}
	d.off = i &#43; 1
}

// value consumes a JSON value from d.data[d.off-1:], decoding into v, and
// reads the following byte ahead. If v is invalid, the value is discarded.
// The first byte of the value has been read already.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.rescanLiteral.png" alt="Control flow graph of rescanLiteral">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) value(v reflect.Value) error {
	switch d.opcode {
	default:
		panic(phasePanicMsg)

	case scanBeginArray:
		if v.IsValid() {
			if err := d.array(v); err != nil {
				return err
			}
		} else {
			d.skip()
		}
		d.scanNext()

	case scanBeginObject:
		if v.IsValid() {
			if err := d.object(v); err != nil {
				return err
			}
		} else {
			d.skip()
		}
		d.scanNext()

	case scanBeginLiteral:
		// All bytes inside literal return scanContinue op code.
		start := d.readIndex()
		d.rescanLiteral()

		if v.IsValid() {
			if err := d.literalStore(d.data[start:d.readIndex()], v, false); err != nil {
				return err
			}
		}
	}
	return nil
}

type unquotedValue struct{}

// valueQuoted is like value but decodes a
// quoted string literal or literal null into an interface value.
// If it finds anything other than a quoted string literal or null,
// valueQuoted returns unquotedValue{}.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.value.png" alt="Control flow graph of value">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) valueQuoted() any {
	switch d.opcode {
	default:
		panic(phasePanicMsg)

	case scanBeginArray, scanBeginObject:
		d.skip()
		d.scanNext()

	case scanBeginLiteral:
		v := d.literalInterface()
		switch v.(type) {
		case nil, string:
			return v
		}
	}
	return unquotedValue{}
}

// indirect walks down v allocating pointers as needed,
// until it gets to a non-pointer.
// If it encounters an Unmarshaler, indirect stops and returns that.
// If decodingNull is true, indirect stops at the first settable pointer so it
// can be set to nil.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.valueQuoted.png" alt="Control flow graph of valueQuoted">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value) {
	// Issue #24153 indicates that it is generally not a guaranteed property
	// that you may round-trip a reflect.Value by calling Value.Addr().Elem()
	// and expect the value to still be settable for values derived from
	// unexported embedded struct fields.
	//
	// The logic below effectively does this when it first addresses the value
	// (to satisfy possible pointer methods) and continues to dereference
	// subsequent pointers as necessary.
	//
	// After the first round-trip, we set v back to the original value to
	// preserve the original RW flags contained in reflect.Value.
	v0 := v
	haveAddr := false

	// If v is a named type and is addressable,
	// start with its address, so that if the type has pointer methods,
	// we find them.
	if v.Kind() != reflect.Pointer &amp;&amp; v.Type().Name() != &#34;&#34; &amp;&amp; v.CanAddr() {
		haveAddr = true
		v = v.Addr()
	}
	for {
		// Load value from interface, but only if the result will be
		// usefully addressable.
		if v.Kind() == reflect.Interface &amp;&amp; !v.IsNil() {
			e := v.Elem()
			if e.Kind() == reflect.Pointer &amp;&amp; !e.IsNil() &amp;&amp; (!decodingNull || e.Elem().Kind() == reflect.Pointer) {
				haveAddr = false
				v = e
				continue
			}
		}

		if v.Kind() != reflect.Pointer {
			break
		}

		if decodingNull &amp;&amp; v.CanSet() {
			break
		}

		// Prevent infinite loop if v is an interface pointing to its own address:
		//     var v interface{}
		//     v = &amp;v
		if v.Elem().Kind() == reflect.Interface &amp;&amp; v.Elem().Elem() == v {
			v = v.Elem()
			break
		}
		if v.IsNil() {
			v.Set(reflect.New(v.Type().Elem()))
		}
		if v.Type().NumMethod() &gt; 0 &amp;&amp; v.CanInterface() {
			if u, ok := v.Interface().(Unmarshaler); ok {
				return u, nil, reflect.Value{}
			}
			if !decodingNull {
				if u, ok := v.Interface().(encoding.TextUnmarshaler); ok {
					return nil, u, reflect.Value{}
				}
			}
		}

		if haveAddr {
			v = v0 // restore original value after round-trip Value.Addr().Elem()
			haveAddr = false
		} else {
			v = v.Elem()
		}
	}
	return nil, nil, v
}

// array consumes an array from d.data[d.off-1:], decoding into v.
// The first byte of the array (&#39;[&#39;) has been read already.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.indirect.png" alt="Control flow graph of indirect">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) array(v reflect.Value) error {
	// Check for unmarshaler.
	u, ut, pv := indirect(v, false)
	if u != nil {
		start := d.readIndex()
		d.skip()
		return u.UnmarshalJSON(d.data[start:d.off])
	}
	if ut != nil {
		d.saveError(&amp;UnmarshalTypeError{Value: &#34;array&#34;, Type: v.Type(), Offset: int64(d.off)})
		d.skip()
		return nil
	}
	v = pv

	// Check type of target.
	switch v.Kind() {
	case reflect.Interface:
		if v.NumMethod() == 0 {
			// Decoding into nil interface? Switch to non-reflect code.
			ai := d.arrayInterface()
			v.Set(reflect.ValueOf(ai))
			return nil
		}
		// Otherwise it&#39;s invalid.
		fallthrough
	default:
		d.saveError(&amp;UnmarshalTypeError{Value: &#34;array&#34;, Type: v.Type(), Offset: int64(d.off)})
		d.skip()
		return nil
	case reflect.Array, reflect.Slice:
		break
	}

	i := 0
	for {
		// Look ahead for ] - can only happen on first iteration.
		d.scanWhile(scanSkipSpace)
		if d.opcode == scanEndArray {
			break
		}

		// Get element of array, growing if necessary.
		if v.Kind() == reflect.Slice {
			// Grow slice if necessary
			if i &gt;= v.Cap() {
				newcap := v.Cap() &#43; v.Cap()/2
				if newcap &lt; 4 {
					newcap = 4
				}
				newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)
				reflect.Copy(newv, v)
				v.Set(newv)
			}
			if i &gt;= v.Len() {
				v.SetLen(i &#43; 1)
			}
		}

		if i &lt; v.Len() {
			// Decode into element.
			if err := d.value(v.Index(i)); err != nil {
				return err
			}
		} else {
			// Ran out of fixed array: skip.
			if err := d.value(reflect.Value{}); err != nil {
				return err
			}
		}
		i&#43;&#43;

		// Next token must be , or ].
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode == scanEndArray {
			break
		}
		if d.opcode != scanArrayValue {
			panic(phasePanicMsg)
		}
	}

	if i &lt; v.Len() {
		if v.Kind() == reflect.Array {
			// Array. Zero the rest.
			z := reflect.Zero(v.Type().Elem())
			for ; i &lt; v.Len(); i&#43;&#43; {
				v.Index(i).Set(z)
			}
		} else {
			v.SetLen(i)
		}
	}
	if i == 0 &amp;&amp; v.Kind() == reflect.Slice {
		v.Set(reflect.MakeSlice(v.Type(), 0, 0))
	}
	return nil
}

var nullLiteral = []byte(&#34;null&#34;)
var textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()

// object consumes an object from d.data[d.off-1:], decoding into v.
// The first byte (&#39;{&#39;) of the object has been read already.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.array.png" alt="Control flow graph of array">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) object(v reflect.Value) error {
	// Check for unmarshaler.
	u, ut, pv := indirect(v, false)
	if u != nil {
		start := d.readIndex()
		d.skip()
		return u.UnmarshalJSON(d.data[start:d.off])
	}
	if ut != nil {
		d.saveError(&amp;UnmarshalTypeError{Value: &#34;object&#34;, Type: v.Type(), Offset: int64(d.off)})
		d.skip()
		return nil
	}
	v = pv
	t := v.Type()

	// Decoding into nil interface? Switch to non-reflect code.
	if v.Kind() == reflect.Interface &amp;&amp; v.NumMethod() == 0 {
		oi := d.objectInterface()
		v.Set(reflect.ValueOf(oi))
		return nil
	}

	var fields structFields

	// Check type of target:
	//   struct or
	//   map[T1]T2 where T1 is string, an integer type,
	//             or an encoding.TextUnmarshaler
	switch v.Kind() {
	case reflect.Map:
		// Map key must either have string kind, have an integer kind,
		// or be an encoding.TextUnmarshaler.
		switch t.Key().Kind() {
		case reflect.String,
			reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		default:
			if !reflect.PointerTo(t.Key()).Implements(textUnmarshalerType) {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;object&#34;, Type: t, Offset: int64(d.off)})
				d.skip()
				return nil
			}
		}
		if v.IsNil() {
			v.Set(reflect.MakeMap(t))
		}
	case reflect.Struct:
		fields = cachedTypeFields(t)
		// ok
	default:
		d.saveError(&amp;UnmarshalTypeError{Value: &#34;object&#34;, Type: t, Offset: int64(d.off)})
		d.skip()
		return nil
	}

	var mapElem reflect.Value
	var origErrorContext errorContext
	if d.errorContext != nil {
		origErrorContext = *d.errorContext
	}

	for {
		// Read opening &#34; of string key or closing }.
		d.scanWhile(scanSkipSpace)
		if d.opcode == scanEndObject {
			// closing } - can only happen on first iteration.
			break
		}
		if d.opcode != scanBeginLiteral {
			panic(phasePanicMsg)
		}

		// Read key.
		start := d.readIndex()
		d.rescanLiteral()
		item := d.data[start:d.readIndex()]
		key, ok := unquoteBytes(item)
		if !ok {
			panic(phasePanicMsg)
		}

		// Figure out field corresponding to key.
		var subv reflect.Value
		destring := false // whether the value is wrapped in a string to be decoded first

		if v.Kind() == reflect.Map {
			elemType := t.Elem()
			if !mapElem.IsValid() {
				mapElem = reflect.New(elemType).Elem()
			} else {
				mapElem.Set(reflect.Zero(elemType))
			}
			subv = mapElem
		} else {
			var f *field
			if i, ok := fields.nameIndex[string(key)]; ok {
				// Found an exact name match.
				f = &amp;fields.list[i]
			} else {
				// Fall back to the expensive case-insensitive
				// linear search.
				for i := range fields.list {
					ff := &amp;fields.list[i]
					if ff.equalFold(ff.nameBytes, key) {
						f = ff
						break
					}
				}
			}
			if f != nil {
				subv = v
				destring = f.quoted
				for _, i := range f.index {
					if subv.Kind() == reflect.Pointer {
						if subv.IsNil() {
							// If a struct embeds a pointer to an unexported type,
							// it is not possible to set a newly allocated value
							// since the field is unexported.
							//
							// See https://golang.org/issue/21357
							if !subv.CanSet() {
								d.saveError(fmt.Errorf(&#34;json: cannot set embedded pointer to unexported struct: %v&#34;, subv.Type().Elem()))
								// Invalidate subv to ensure d.value(subv) skips over
								// the JSON value without assigning it to subv.
								subv = reflect.Value{}
								destring = false
								break
							}
							subv.Set(reflect.New(subv.Type().Elem()))
						}
						subv = subv.Elem()
					}
					subv = subv.Field(i)
				}
				if d.errorContext == nil {
					d.errorContext = new(errorContext)
				}
				d.errorContext.FieldStack = append(d.errorContext.FieldStack, f.name)
				d.errorContext.Struct = t
			} else if d.disallowUnknownFields {
				d.saveError(fmt.Errorf(&#34;json: unknown field %q&#34;, key))
			}
		}

		// Read : before value.
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode != scanObjectKey {
			panic(phasePanicMsg)
		}
		d.scanWhile(scanSkipSpace)

		if destring {
			switch qv := d.valueQuoted().(type) {
			case nil:
				if err := d.literalStore(nullLiteral, subv, false); err != nil {
					return err
				}
			case string:
				if err := d.literalStore([]byte(qv), subv, true); err != nil {
					return err
				}
			default:
				d.saveError(fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal unquoted value into %v&#34;, subv.Type()))
			}
		} else {
			if err := d.value(subv); err != nil {
				return err
			}
		}

		// Write value back to map;
		// if using struct, subv points into struct already.
		if v.Kind() == reflect.Map {
			kt := t.Key()
			var kv reflect.Value
			switch {
			case reflect.PointerTo(kt).Implements(textUnmarshalerType):
				kv = reflect.New(kt)
				if err := d.literalStore(item, kv, true); err != nil {
					return err
				}
				kv = kv.Elem()
			case kt.Kind() == reflect.String:
				kv = reflect.ValueOf(key).Convert(kt)
			default:
				switch kt.Kind() {
				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
					s := string(key)
					n, err := strconv.ParseInt(s, 10, 64)
					if err != nil || reflect.Zero(kt).OverflowInt(n) {
						d.saveError(&amp;UnmarshalTypeError{Value: &#34;number &#34; &#43; s, Type: kt, Offset: int64(start &#43; 1)})
						break
					}
					kv = reflect.ValueOf(n).Convert(kt)
				case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
					s := string(key)
					n, err := strconv.ParseUint(s, 10, 64)
					if err != nil || reflect.Zero(kt).OverflowUint(n) {
						d.saveError(&amp;UnmarshalTypeError{Value: &#34;number &#34; &#43; s, Type: kt, Offset: int64(start &#43; 1)})
						break
					}
					kv = reflect.ValueOf(n).Convert(kt)
				default:
					panic(&#34;json: Unexpected key type&#34;) // should never occur
				}
			}
			if kv.IsValid() {
				v.SetMapIndex(kv, subv)
			}
		}

		// Next token must be , or }.
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.errorContext != nil {
			// Reset errorContext to its original state.
			// Keep the same underlying array for FieldStack, to reuse the
			// space and avoid unnecessary allocs.
			d.errorContext.FieldStack = d.errorContext.FieldStack[:len(origErrorContext.FieldStack)]
			d.errorContext.Struct = origErrorContext.Struct
		}
		if d.opcode == scanEndObject {
			break
		}
		if d.opcode != scanObjectValue {
			panic(phasePanicMsg)
		}
	}
	return nil
}

// convertNumber converts the number literal s to a float64 or a Number
// depending on the setting of d.useNumber.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.object.png" alt="Control flow graph of object">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) convertNumber(s string) (any, error) {
	if d.useNumber {
		return Number(s), nil
	}
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return nil, &amp;UnmarshalTypeError{Value: &#34;number &#34; &#43; s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)}
	}
	return f, nil
}

var numberType = reflect.TypeOf(Number(&#34;&#34;))

// literalStore decodes a literal stored in item into v.
//
// fromQuoted indicates whether this literal came from unwrapping a
// string from the &#34;,string&#34; struct tag option. this is used only to
// produce more helpful error messages.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.convertNumber.png" alt="Control flow graph of convertNumber">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) error {
	// Check for unmarshaler.
	if len(item) == 0 {
		//Empty string given
		d.saveError(fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type()))
		return nil
	}
	isNull := item[0] == &#39;n&#39; // null
	u, ut, pv := indirect(v, isNull)
	if u != nil {
		return u.UnmarshalJSON(item)
	}
	if ut != nil {
		if item[0] != &#39;&#34;&#39; {
			if fromQuoted {
				d.saveError(fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type()))
				return nil
			}
			val := &#34;number&#34;
			switch item[0] {
			case &#39;n&#39;:
				val = &#34;null&#34;
			case &#39;t&#39;, &#39;f&#39;:
				val = &#34;bool&#34;
			}
			d.saveError(&amp;UnmarshalTypeError{Value: val, Type: v.Type(), Offset: int64(d.readIndex())})
			return nil
		}
		s, ok := unquoteBytes(item)
		if !ok {
			if fromQuoted {
				return fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type())
			}
			panic(phasePanicMsg)
		}
		return ut.UnmarshalText(s)
	}

	v = pv

	switch c := item[0]; c {
	case &#39;n&#39;: // null
		// The main parser checks that only true and false can reach here,
		// but if this was a quoted string input, it could be anything.
		if fromQuoted &amp;&amp; string(item) != &#34;null&#34; {
			d.saveError(fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type()))
			break
		}
		switch v.Kind() {
		case reflect.Interface, reflect.Pointer, reflect.Map, reflect.Slice:
			v.Set(reflect.Zero(v.Type()))
			// otherwise, ignore null for primitives/string
		}
	case &#39;t&#39;, &#39;f&#39;: // true, false
		value := item[0] == &#39;t&#39;
		// The main parser checks that only true and false can reach here,
		// but if this was a quoted string input, it could be anything.
		if fromQuoted &amp;&amp; string(item) != &#34;true&#34; &amp;&amp; string(item) != &#34;false&#34; {
			d.saveError(fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type()))
			break
		}
		switch v.Kind() {
		default:
			if fromQuoted {
				d.saveError(fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type()))
			} else {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;bool&#34;, Type: v.Type(), Offset: int64(d.readIndex())})
			}
		case reflect.Bool:
			v.SetBool(value)
		case reflect.Interface:
			if v.NumMethod() == 0 {
				v.Set(reflect.ValueOf(value))
			} else {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;bool&#34;, Type: v.Type(), Offset: int64(d.readIndex())})
			}
		}

	case &#39;&#34;&#39;: // string
		s, ok := unquoteBytes(item)
		if !ok {
			if fromQuoted {
				return fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type())
			}
			panic(phasePanicMsg)
		}
		switch v.Kind() {
		default:
			d.saveError(&amp;UnmarshalTypeError{Value: &#34;string&#34;, Type: v.Type(), Offset: int64(d.readIndex())})
		case reflect.Slice:
			if v.Type().Elem().Kind() != reflect.Uint8 {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;string&#34;, Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			b := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
			n, err := base64.StdEncoding.Decode(b, s)
			if err != nil {
				d.saveError(err)
				break
			}
			v.SetBytes(b[:n])
		case reflect.String:
			if v.Type() == numberType &amp;&amp; !isValidNumber(string(s)) {
				return fmt.Errorf(&#34;json: invalid number literal, trying to unmarshal %q into Number&#34;, item)
			}
			v.SetString(string(s))
		case reflect.Interface:
			if v.NumMethod() == 0 {
				v.Set(reflect.ValueOf(string(s)))
			} else {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;string&#34;, Type: v.Type(), Offset: int64(d.readIndex())})
			}
		}

	default: // number
		if c != &#39;-&#39; &amp;&amp; (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
			if fromQuoted {
				return fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type())
			}
			panic(phasePanicMsg)
		}
		s := string(item)
		switch v.Kind() {
		default:
			if v.Kind() == reflect.String &amp;&amp; v.Type() == numberType {
				// s must be a valid number, because it&#39;s
				// already been tokenized.
				v.SetString(s)
				break
			}
			if fromQuoted {
				return fmt.Errorf(&#34;json: invalid use of ,string struct tag, trying to unmarshal %q into %v&#34;, item, v.Type())
			}
			d.saveError(&amp;UnmarshalTypeError{Value: &#34;number&#34;, Type: v.Type(), Offset: int64(d.readIndex())})
		case reflect.Interface:
			n, err := d.convertNumber(s)
			if err != nil {
				d.saveError(err)
				break
			}
			if v.NumMethod() != 0 {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;number&#34;, Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			v.Set(reflect.ValueOf(n))

		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			n, err := strconv.ParseInt(s, 10, 64)
			if err != nil || v.OverflowInt(n) {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;number &#34; &#43; s, Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			v.SetInt(n)

		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
			n, err := strconv.ParseUint(s, 10, 64)
			if err != nil || v.OverflowUint(n) {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;number &#34; &#43; s, Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			v.SetUint(n)

		case reflect.Float32, reflect.Float64:
			n, err := strconv.ParseFloat(s, v.Type().Bits())
			if err != nil || v.OverflowFloat(n) {
				d.saveError(&amp;UnmarshalTypeError{Value: &#34;number &#34; &#43; s, Type: v.Type(), Offset: int64(d.readIndex())})
				break
			}
			v.SetFloat(n)
		}
	}
	return nil
}

// The xxxInterface routines build up a value to be stored
// in an empty interface. They are not strictly necessary,
// but they avoid the weight of reflection in this common case.

// valueInterface is like value but returns interface{}
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.literalStore.png" alt="Control flow graph of literalStore">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) valueInterface() (val any) {
	switch d.opcode {
	default:
		panic(phasePanicMsg)
	case scanBeginArray:
		val = d.arrayInterface()
		d.scanNext()
	case scanBeginObject:
		val = d.objectInterface()
		d.scanNext()
	case scanBeginLiteral:
		val = d.literalInterface()
	}
	return
}

// arrayInterface is like array but returns []interface{}.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.valueInterface.png" alt="Control flow graph of valueInterface">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) arrayInterface() []any {
	var v = make([]any, 0)
	for {
		// Look ahead for ] - can only happen on first iteration.
		d.scanWhile(scanSkipSpace)
		if d.opcode == scanEndArray {
			break
		}

		v = append(v, d.valueInterface())

		// Next token must be , or ].
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode == scanEndArray {
			break
		}
		if d.opcode != scanArrayValue {
			panic(phasePanicMsg)
		}
	}
	return v
}

// objectInterface is like object but returns map[string]interface{}.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.arrayInterface.png" alt="Control flow graph of arrayInterface">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) objectInterface() map[string]any {
	m := make(map[string]any)
	for {
		// Read opening &#34; of string key or closing }.
		d.scanWhile(scanSkipSpace)
		if d.opcode == scanEndObject {
			// closing } - can only happen on first iteration.
			break
		}
		if d.opcode != scanBeginLiteral {
			panic(phasePanicMsg)
		}

		// Read string key.
		start := d.readIndex()
		d.rescanLiteral()
		item := d.data[start:d.readIndex()]
		key, ok := unquote(item)
		if !ok {
			panic(phasePanicMsg)
		}

		// Read : before value.
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode != scanObjectKey {
			panic(phasePanicMsg)
		}
		d.scanWhile(scanSkipSpace)

		// Read value.
		m[key] = d.valueInterface()

		// Next token must be , or }.
		if d.opcode == scanSkipSpace {
			d.scanWhile(scanSkipSpace)
		}
		if d.opcode == scanEndObject {
			break
		}
		if d.opcode != scanObjectValue {
			panic(phasePanicMsg)
		}
	}
	return m
}

// literalInterface consumes and returns a literal from d.data[d.off-1:] and
// it reads the following byte ahead. The first byte of the literal has been
// read already (that&#39;s how the caller knows it&#39;s a literal).
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.objectInterface.png" alt="Control flow graph of objectInterface">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (d *decodeState) literalInterface() any {
	// All bytes inside literal return scanContinue op code.
	start := d.readIndex()
	d.rescanLiteral()

	item := d.data[start:d.readIndex()]

	switch c := item[0]; c {
	case &#39;n&#39;: // null
		return nil

	case &#39;t&#39;, &#39;f&#39;: // true, false
		return c == &#39;t&#39;

	case &#39;&#34;&#39;: // string
		s, ok := unquote(item)
		if !ok {
			panic(phasePanicMsg)
		}
		return s

	default: // number
		if c != &#39;-&#39; &amp;&amp; (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;) {
			panic(phasePanicMsg)
		}
		n, err := d.convertNumber(string(item))
		if err != nil {
			d.saveError(err)
		}
		return n
	}
}

// getu4 decodes \uXXXX from the beginning of s, returning the hex value,
// or it returns -1.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.literalInterface.png" alt="Control flow graph of literalInterface">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func getu4(s []byte) rune {
	if len(s) &lt; 6 || s[0] != &#39;\\&#39; || s[1] != &#39;u&#39; {
		return -1
	}
	var r rune
	for _, c := range s[2:6] {
		switch {
		case &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;:
			c = c - &#39;0&#39;
		case &#39;a&#39; &lt;= c &amp;&amp; c &lt;= &#39;f&#39;:
			c = c - &#39;a&#39; &#43; 10
		case &#39;A&#39; &lt;= c &amp;&amp; c &lt;= &#39;F&#39;:
			c = c - &#39;A&#39; &#43; 10
		default:
			return -1
		}
		r = r*16 &#43; rune(c)
	}
	return r
}

// unquote converts a quoted JSON string literal s into an actual string t.
// The rules are different than for Go, so cannot use strconv.Unquote.
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.getu4.png" alt="Control flow graph of getu4">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func unquote(s []byte) (t string, ok bool) {
	s, ok = unquoteBytes(s)
	t = string(s)
	return
}

</pre>
            </td>
            <td>
                
                    <img src="decode.go._.unquote.png" alt="Control flow graph of unquote">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func unquoteBytes(s []byte) (t []byte, ok bool) {
	if len(s) &lt; 2 || s[0] != &#39;&#34;&#39; || s[len(s)-1] != &#39;&#34;&#39; {
		return
	}
	s = s[1 : len(s)-1]

	// Check for unusual characters. If there are none,
	// then no unquoting is needed, so return a slice of the
	// original bytes.
	r := 0
	for r &lt; len(s) {
		c := s[r]
		if c == &#39;\\&#39; || c == &#39;&#34;&#39; || c &lt; &#39; &#39; {
			break
		}
		if c &lt; utf8.RuneSelf {
			r&#43;&#43;
			continue
		}
		rr, size := utf8.DecodeRune(s[r:])
		if rr == utf8.RuneError &amp;&amp; size == 1 {
			break
		}
		r &#43;= size
	}
	if r == len(s) {
		return s, true
	}

	b := make([]byte, len(s)&#43;2*utf8.UTFMax)
	w := copy(b, s[0:r])
	for r &lt; len(s) {
		// Out of room? Can only happen if s is full of
		// malformed UTF-8 and we&#39;re replacing each
		// byte with RuneError.
		if w &gt;= len(b)-2*utf8.UTFMax {
			nb := make([]byte, (len(b)&#43;utf8.UTFMax)*2)
			copy(nb, b[0:w])
			b = nb
		}
		switch c := s[r]; {
		case c == &#39;\\&#39;:
			r&#43;&#43;
			if r &gt;= len(s) {
				return
			}
			switch s[r] {
			default:
				return
			case &#39;&#34;&#39;, &#39;\\&#39;, &#39;/&#39;, &#39;\&#39;&#39;:
				b[w] = s[r]
				r&#43;&#43;
				w&#43;&#43;
			case &#39;b&#39;:
				b[w] = &#39;\b&#39;
				r&#43;&#43;
				w&#43;&#43;
			case &#39;f&#39;:
				b[w] = &#39;\f&#39;
				r&#43;&#43;
				w&#43;&#43;
			case &#39;n&#39;:
				b[w] = &#39;\n&#39;
				r&#43;&#43;
				w&#43;&#43;
			case &#39;r&#39;:
				b[w] = &#39;\r&#39;
				r&#43;&#43;
				w&#43;&#43;
			case &#39;t&#39;:
				b[w] = &#39;\t&#39;
				r&#43;&#43;
				w&#43;&#43;
			case &#39;u&#39;:
				r--
				rr := getu4(s[r:])
				if rr &lt; 0 {
					return
				}
				r &#43;= 6
				if utf16.IsSurrogate(rr) {
					rr1 := getu4(s[r:])
					if dec := utf16.DecodeRune(rr, rr1); dec != unicode.ReplacementChar {
						// A valid pair; consume.
						r &#43;= 6
						w &#43;= utf8.EncodeRune(b[w:], dec)
						break
					}
					// Invalid surrogate; fall back to replacement rune.
					rr = unicode.ReplacementChar
				}
				w &#43;= utf8.EncodeRune(b[w:], rr)
			}

		// Quote, control characters are invalid.
		case c == &#39;&#34;&#39;, c &lt; &#39; &#39;:
			return

		// ASCII
		case c &lt; utf8.RuneSelf:
			b[w] = c
			r&#43;&#43;
			w&#43;&#43;

		// Coerce to well-formed UTF-8.
		default:
			rr, size := utf8.DecodeRune(s[r:])
			r &#43;= size
			w &#43;= utf8.EncodeRune(b[w:], rr)
		}
	}
	return b[0:w], true
}
</pre>
            </td>
            <td>
                
                    <img src="decode.go._.unquoteBytes.png" alt="Control flow graph of unquoteBytes">
                
            </td>
        </tr>
    
</table>
</body>
</html>