<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>format.go Graph Overview</title>
    <style>
        td {
            vertical-align: top;
        }

        pre {
            padding-right: 200px;
        }

        td {
            border-top: solid 1px blue;
        }
    </style>
</head>
<body>
<h1>
    File: <code>format.go</code>
</h1>
<table>
    
        <tr>
            <td>
            <pre>// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fmt

import (
	&#34;strconv&#34;
	&#34;unicode/utf8&#34;
)

const (
	ldigits = &#34;0123456789abcdefx&#34;
	udigits = &#34;0123456789ABCDEFX&#34;
)

const (
	signed   = true
	unsigned = false
)

// flags placed in a separate struct for easy clearing.
type fmtFlags struct {
	widPresent  bool
	precPresent bool
	minus       bool
	plus        bool
	sharp       bool
	space       bool
	zero        bool

	// For the formats %&#43;v %#v, we set the plusV/sharpV flags
	// and clear the plus/sharp flags since %&#43;v and %#v are in effect
	// different, flagless formats set at the top level.
	plusV  bool
	sharpV bool
}

// A fmt is the raw formatter used by Printf etc.
// It prints into a buffer that must be set up separately.
type fmt struct {
	buf *buffer

	fmtFlags

	wid  int // width
	prec int // precision

	// intbuf is large enough to store %b of an int64 with a sign and
	// avoids padding at the end of the struct on 32 bit architectures.
	intbuf [68]byte
}

</pre>
            </td>
            <td>
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) clearflags() {
	f.fmtFlags = fmtFlags{}
}

</pre>
            </td>
            <td>
                
                    <img src="format.go._.clearflags.png" alt="Control flow graph of clearflags">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) init(buf *buffer) {
	f.buf = buf
	f.clearflags()
}

// writePadding generates n bytes of padding.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.init.png" alt="Control flow graph of init">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) writePadding(n int) {
	if n &lt;= 0 { // No padding bytes needed.
		return
	}
	buf := *f.buf
	oldLen := len(buf)
	newLen := oldLen &#43; n
	// Make enough room for padding.
	if newLen &gt; cap(buf) {
		buf = make(buffer, cap(buf)*2&#43;n)
		copy(buf, *f.buf)
	}
	// Decide which byte the padding should be filled with.
	padByte := byte(&#39; &#39;)
	if f.zero {
		padByte = byte(&#39;0&#39;)
	}
	// Fill padding with padByte.
	padding := buf[oldLen:newLen]
	for i := range padding {
		padding[i] = padByte
	}
	*f.buf = buf[:newLen]
}

// pad appends b to f.buf, padded on left (!f.minus) or right (f.minus).
</pre>
            </td>
            <td>
                
                    <img src="format.go._.writePadding.png" alt="Control flow graph of writePadding">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) pad(b []byte) {
	if !f.widPresent || f.wid == 0 {
		f.buf.write(b)
		return
	}
	width := f.wid - utf8.RuneCount(b)
	if !f.minus {
		// left padding
		f.writePadding(width)
		f.buf.write(b)
	} else {
		// right padding
		f.buf.write(b)
		f.writePadding(width)
	}
}

// padString appends s to f.buf, padded on left (!f.minus) or right (f.minus).
</pre>
            </td>
            <td>
                
                    <img src="format.go._.pad.png" alt="Control flow graph of pad">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) padString(s string) {
	if !f.widPresent || f.wid == 0 {
		f.buf.writeString(s)
		return
	}
	width := f.wid - utf8.RuneCountInString(s)
	if !f.minus {
		// left padding
		f.writePadding(width)
		f.buf.writeString(s)
	} else {
		// right padding
		f.buf.writeString(s)
		f.writePadding(width)
	}
}

// fmtBoolean formats a boolean.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.padString.png" alt="Control flow graph of padString">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtBoolean(v bool) {
	if v {
		f.padString(&#34;true&#34;)
	} else {
		f.padString(&#34;false&#34;)
	}
}

// fmtUnicode formats a uint64 as &#34;U&#43;0078&#34; or with f.sharp set as &#34;U&#43;0078 &#39;x&#39;&#34;.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtBoolean.png" alt="Control flow graph of fmtBoolean">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtUnicode(u uint64) {
	buf := f.intbuf[0:]

	// With default precision set the maximum needed buf length is 18
	// for formatting -1 with %#U (&#34;U&#43;FFFFFFFFFFFFFFFF&#34;) which fits
	// into the already allocated intbuf with a capacity of 68 bytes.
	prec := 4
	if f.precPresent &amp;&amp; f.prec &gt; 4 {
		prec = f.prec
		// Compute space needed for &#34;U&#43;&#34; , number, &#34; &#39;&#34;, character, &#34;&#39;&#34;.
		width := 2 &#43; prec &#43; 2 &#43; utf8.UTFMax &#43; 1
		if width &gt; len(buf) {
			buf = make([]byte, width)
		}
	}

	// Format into buf, ending at buf[i]. Formatting numbers is easier right-to-left.
	i := len(buf)

	// For %#U we want to add a space and a quoted character at the end of the buffer.
	if f.sharp &amp;&amp; u &lt;= utf8.MaxRune &amp;&amp; strconv.IsPrint(rune(u)) {
		i--
		buf[i] = &#39;\&#39;&#39;
		i -= utf8.RuneLen(rune(u))
		utf8.EncodeRune(buf[i:], rune(u))
		i--
		buf[i] = &#39;\&#39;&#39;
		i--
		buf[i] = &#39; &#39;
	}
	// Format the Unicode code point u as a hexadecimal number.
	for u &gt;= 16 {
		i--
		buf[i] = udigits[u&amp;0xF]
		prec--
		u &gt;&gt;= 4
	}
	i--
	buf[i] = udigits[u]
	prec--
	// Add zeros in front of the number until requested precision is reached.
	for prec &gt; 0 {
		i--
		buf[i] = &#39;0&#39;
		prec--
	}
	// Add a leading &#34;U&#43;&#34;.
	i--
	buf[i] = &#39;&#43;&#39;
	i--
	buf[i] = &#39;U&#39;

	oldZero := f.zero
	f.zero = false
	f.pad(buf[i:])
	f.zero = oldZero
}

// fmtInteger formats signed and unsigned integers.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtUnicode.png" alt="Control flow graph of fmtUnicode">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtInteger(u uint64, base int, isSigned bool, verb rune, digits string) {
	negative := isSigned &amp;&amp; int64(u) &lt; 0
	if negative {
		u = -u
	}

	buf := f.intbuf[0:]
	// The already allocated f.intbuf with a capacity of 68 bytes
	// is large enough for integer formatting when no precision or width is set.
	if f.widPresent || f.precPresent {
		// Account 3 extra bytes for possible addition of a sign and &#34;0x&#34;.
		width := 3 &#43; f.wid &#43; f.prec // wid and prec are always positive.
		if width &gt; len(buf) {
			// We&#39;re going to need a bigger boat.
			buf = make([]byte, width)
		}
	}

	// Two ways to ask for extra leading zero digits: %.3d or %03d.
	// If both are specified the f.zero flag is ignored and
	// padding with spaces is used instead.
	prec := 0
	if f.precPresent {
		prec = f.prec
		// Precision of 0 and value of 0 means &#34;print nothing&#34; but padding.
		if prec == 0 &amp;&amp; u == 0 {
			oldZero := f.zero
			f.zero = false
			f.writePadding(f.wid)
			f.zero = oldZero
			return
		}
	} else if f.zero &amp;&amp; f.widPresent {
		prec = f.wid
		if negative || f.plus || f.space {
			prec-- // leave room for sign
		}
	}

	// Because printing is easier right-to-left: format u into buf, ending at buf[i].
	// We could make things marginally faster by splitting the 32-bit case out
	// into a separate block but it&#39;s not worth the duplication, so u has 64 bits.
	i := len(buf)
	// Use constants for the division and modulo for more efficient code.
	// Switch cases ordered by popularity.
	switch base {
	case 10:
		for u &gt;= 10 {
			i--
			next := u / 10
			buf[i] = byte(&#39;0&#39; &#43; u - next*10)
			u = next
		}
	case 16:
		for u &gt;= 16 {
			i--
			buf[i] = digits[u&amp;0xF]
			u &gt;&gt;= 4
		}
	case 8:
		for u &gt;= 8 {
			i--
			buf[i] = byte(&#39;0&#39; &#43; u&amp;7)
			u &gt;&gt;= 3
		}
	case 2:
		for u &gt;= 2 {
			i--
			buf[i] = byte(&#39;0&#39; &#43; u&amp;1)
			u &gt;&gt;= 1
		}
	default:
		panic(&#34;fmt: unknown base; can&#39;t happen&#34;)
	}
	i--
	buf[i] = digits[u]
	for i &gt; 0 &amp;&amp; prec &gt; len(buf)-i {
		i--
		buf[i] = &#39;0&#39;
	}

	// Various prefixes: 0x, -, etc.
	if f.sharp {
		switch base {
		case 2:
			// Add a leading 0b.
			i--
			buf[i] = &#39;b&#39;
			i--
			buf[i] = &#39;0&#39;
		case 8:
			if buf[i] != &#39;0&#39; {
				i--
				buf[i] = &#39;0&#39;
			}
		case 16:
			// Add a leading 0x or 0X.
			i--
			buf[i] = digits[16]
			i--
			buf[i] = &#39;0&#39;
		}
	}
	if verb == &#39;O&#39; {
		i--
		buf[i] = &#39;o&#39;
		i--
		buf[i] = &#39;0&#39;
	}

	if negative {
		i--
		buf[i] = &#39;-&#39;
	} else if f.plus {
		i--
		buf[i] = &#39;&#43;&#39;
	} else if f.space {
		i--
		buf[i] = &#39; &#39;
	}

	// Left padding with zeros has already been handled like precision earlier
	// or the f.zero flag is ignored due to an explicitly set precision.
	oldZero := f.zero
	f.zero = false
	f.pad(buf[i:])
	f.zero = oldZero
}

// truncateString truncates the string s to the specified precision, if present.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtInteger.png" alt="Control flow graph of fmtInteger">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) truncateString(s string) string {
	if f.precPresent {
		n := f.prec
		for i := range s {
			n--
			if n &lt; 0 {
				return s[:i]
			}
		}
	}
	return s
}

// truncate truncates the byte slice b as a string of the specified precision, if present.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.truncateString.png" alt="Control flow graph of truncateString">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) truncate(b []byte) []byte {
	if f.precPresent {
		n := f.prec
		for i := 0; i &lt; len(b); {
			n--
			if n &lt; 0 {
				return b[:i]
			}
			wid := 1
			if b[i] &gt;= utf8.RuneSelf {
				_, wid = utf8.DecodeRune(b[i:])
			}
			i &#43;= wid
		}
	}
	return b
}

// fmtS formats a string.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.truncate.png" alt="Control flow graph of truncate">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtS(s string) {
	s = f.truncateString(s)
	f.padString(s)
}

// fmtBs formats the byte slice b as if it was formatted as string with fmtS.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtS.png" alt="Control flow graph of fmtS">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtBs(b []byte) {
	b = f.truncate(b)
	f.pad(b)
}

// fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtBs.png" alt="Control flow graph of fmtBs">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtSbx(s string, b []byte, digits string) {
	length := len(b)
	if b == nil {
		// No byte slice present. Assume string s should be encoded.
		length = len(s)
	}
	// Set length to not process more bytes than the precision demands.
	if f.precPresent &amp;&amp; f.prec &lt; length {
		length = f.prec
	}
	// Compute width of the encoding taking into account the f.sharp and f.space flag.
	width := 2 * length
	if width &gt; 0 {
		if f.space {
			// Each element encoded by two hexadecimals will get a leading 0x or 0X.
			if f.sharp {
				width *= 2
			}
			// Elements will be separated by a space.
			width &#43;= length - 1
		} else if f.sharp {
			// Only a leading 0x or 0X will be added for the whole string.
			width &#43;= 2
		}
	} else { // The byte slice or string that should be encoded is empty.
		if f.widPresent {
			f.writePadding(f.wid)
		}
		return
	}
	// Handle padding to the left.
	if f.widPresent &amp;&amp; f.wid &gt; width &amp;&amp; !f.minus {
		f.writePadding(f.wid - width)
	}
	// Write the encoding directly into the output buffer.
	buf := *f.buf
	if f.sharp {
		// Add leading 0x or 0X.
		buf = append(buf, &#39;0&#39;, digits[16])
	}
	var c byte
	for i := 0; i &lt; length; i&#43;&#43; {
		if f.space &amp;&amp; i &gt; 0 {
			// Separate elements with a space.
			buf = append(buf, &#39; &#39;)
			if f.sharp {
				// Add leading 0x or 0X for each element.
				buf = append(buf, &#39;0&#39;, digits[16])
			}
		}
		if b != nil {
			c = b[i] // Take a byte from the input byte slice.
		} else {
			c = s[i] // Take a byte from the input string.
		}
		// Encode each byte as two hexadecimal digits.
		buf = append(buf, digits[c&gt;&gt;4], digits[c&amp;0xF])
	}
	*f.buf = buf
	// Handle padding to the right.
	if f.widPresent &amp;&amp; f.wid &gt; width &amp;&amp; f.minus {
		f.writePadding(f.wid - width)
	}
}

// fmtSx formats a string as a hexadecimal encoding of its bytes.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtSbx.png" alt="Control flow graph of fmtSbx">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtSx(s, digits string) {
	f.fmtSbx(s, nil, digits)
}

// fmtBx formats a byte slice as a hexadecimal encoding of its bytes.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtSx.png" alt="Control flow graph of fmtSx">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtBx(b []byte, digits string) {
	f.fmtSbx(&#34;&#34;, b, digits)
}

// fmtQ formats a string as a double-quoted, escaped Go string constant.
// If f.sharp is set a raw (backquoted) string may be returned instead
// if the string does not contain any control characters other than tab.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtBx.png" alt="Control flow graph of fmtBx">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtQ(s string) {
	s = f.truncateString(s)
	if f.sharp &amp;&amp; strconv.CanBackquote(s) {
		f.padString(&#34;`&#34; &#43; s &#43; &#34;`&#34;)
		return
	}
	buf := f.intbuf[:0]
	if f.plus {
		f.pad(strconv.AppendQuoteToASCII(buf, s))
	} else {
		f.pad(strconv.AppendQuote(buf, s))
	}
}

// fmtC formats an integer as a Unicode character.
// If the character is not valid Unicode, it will print &#39;\ufffd&#39;.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtQ.png" alt="Control flow graph of fmtQ">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtC(c uint64) {
	r := rune(c)
	if c &gt; utf8.MaxRune {
		r = utf8.RuneError
	}
	buf := f.intbuf[:0]
	w := utf8.EncodeRune(buf[:utf8.UTFMax], r)
	f.pad(buf[:w])
}

// fmtQc formats an integer as a single-quoted, escaped Go character constant.
// If the character is not valid Unicode, it will print &#39;\ufffd&#39;.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtC.png" alt="Control flow graph of fmtC">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtQc(c uint64) {
	r := rune(c)
	if c &gt; utf8.MaxRune {
		r = utf8.RuneError
	}
	buf := f.intbuf[:0]
	if f.plus {
		f.pad(strconv.AppendQuoteRuneToASCII(buf, r))
	} else {
		f.pad(strconv.AppendQuoteRune(buf, r))
	}
}

// fmtFloat formats a float64. It assumes that verb is a valid format specifier
// for strconv.AppendFloat and therefore fits into a byte.
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtQc.png" alt="Control flow graph of fmtQc">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (f *fmt) fmtFloat(v float64, size int, verb rune, prec int) {
	// Explicit precision in format specifier overrules default precision.
	if f.precPresent {
		prec = f.prec
	}
	// Format number, reserving space for leading &#43; sign if needed.
	num := strconv.AppendFloat(f.intbuf[:1], v, byte(verb), prec, size)
	if num[1] == &#39;-&#39; || num[1] == &#39;&#43;&#39; {
		num = num[1:]
	} else {
		num[0] = &#39;&#43;&#39;
	}
	// f.space means to add a leading space instead of a &#34;&#43;&#34; sign unless
	// the sign is explicitly asked for by f.plus.
	if f.space &amp;&amp; num[0] == &#39;&#43;&#39; &amp;&amp; !f.plus {
		num[0] = &#39; &#39;
	}
	// Special handling for infinities and NaN,
	// which don&#39;t look like a number so shouldn&#39;t be padded with zeros.
	if num[1] == &#39;I&#39; || num[1] == &#39;N&#39; {
		oldZero := f.zero
		f.zero = false
		// Remove sign before NaN if not asked for.
		if num[1] == &#39;N&#39; &amp;&amp; !f.space &amp;&amp; !f.plus {
			num = num[1:]
		}
		f.pad(num)
		f.zero = oldZero
		return
	}
	// The sharp flag forces printing a decimal point for non-binary formats
	// and retains trailing zeros, which we may need to restore.
	if f.sharp &amp;&amp; verb != &#39;b&#39; {
		digits := 0
		switch verb {
		case &#39;v&#39;, &#39;g&#39;, &#39;G&#39;, &#39;x&#39;:
			digits = prec
			// If no precision is set explicitly use a precision of 6.
			if digits == -1 {
				digits = 6
			}
		}

		// Buffer pre-allocated with enough room for
		// exponent notations of the form &#34;e&#43;123&#34; or &#34;p-1023&#34;.
		var tailBuf [6]byte
		tail := tailBuf[:0]

		hasDecimalPoint := false
		sawNonzeroDigit := false
		// Starting from i = 1 to skip sign at num[0].
		for i := 1; i &lt; len(num); i&#43;&#43; {
			switch num[i] {
			case &#39;.&#39;:
				hasDecimalPoint = true
			case &#39;p&#39;, &#39;P&#39;:
				tail = append(tail, num[i:]...)
				num = num[:i]
			case &#39;e&#39;, &#39;E&#39;:
				if verb != &#39;x&#39; &amp;&amp; verb != &#39;X&#39; {
					tail = append(tail, num[i:]...)
					num = num[:i]
					break
				}
				fallthrough
			default:
				if num[i] != &#39;0&#39; {
					sawNonzeroDigit = true
				}
				// Count significant digits after the first non-zero digit.
				if sawNonzeroDigit {
					digits--
				}
			}
		}
		if !hasDecimalPoint {
			// Leading digit 0 should contribute once to digits.
			if len(num) == 2 &amp;&amp; num[1] == &#39;0&#39; {
				digits--
			}
			num = append(num, &#39;.&#39;)
		}
		for digits &gt; 0 {
			num = append(num, &#39;0&#39;)
			digits--
		}
		num = append(num, tail...)
	}
	// We want a sign if asked for and if the sign is not positive.
	if f.plus || num[0] != &#39;&#43;&#39; {
		// If we&#39;re zero padding to the left we want the sign before the leading zeros.
		// Achieve this by writing the sign out and then padding the unsigned number.
		if f.zero &amp;&amp; f.widPresent &amp;&amp; f.wid &gt; len(num) {
			f.buf.writeByte(num[0])
			f.writePadding(f.wid - len(num))
			f.buf.write(num[1:])
			return
		}
		f.pad(num)
		return
	}
	// No sign to show and the number is positive; just print the unsigned number.
	f.pad(num[1:])
}
</pre>
            </td>
            <td>
                
                    <img src="format.go._.fmtFloat.png" alt="Control flow graph of fmtFloat">
                
            </td>
        </tr>
    
</table>
</body>
</html>