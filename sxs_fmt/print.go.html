<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>print.go Graph Overview</title>
    <style>
        td {
            vertical-align: top;
        }

        pre {
            padding-right: 200px;
        }

        td {
            border-top: solid 1px blue;
        }
    </style>
</head>
<body>
<h1>
    File: <code>print.go</code>
</h1>
<table>
    
        <tr>
            <td>
            <pre>// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package fmt

import (
	&#34;internal/fmtsort&#34;
	&#34;io&#34;
	&#34;os&#34;
	&#34;reflect&#34;
	&#34;sync&#34;
	&#34;unicode/utf8&#34;
)

// Strings for use with buffer.WriteString.
// This is less overhead than using buffer.Write with byte arrays.
const (
	commaSpaceString  = &#34;, &#34;
	nilAngleString    = &#34;&lt;nil&gt;&#34;
	nilParenString    = &#34;(nil)&#34;
	nilString         = &#34;nil&#34;
	mapString         = &#34;map[&#34;
	percentBangString = &#34;%!&#34;
	missingString     = &#34;(MISSING)&#34;
	badIndexString    = &#34;(BADINDEX)&#34;
	panicString       = &#34;(PANIC=&#34;
	extraString       = &#34;%!(EXTRA &#34;
	badWidthString    = &#34;%!(BADWIDTH)&#34;
	badPrecString     = &#34;%!(BADPREC)&#34;
	noVerbString      = &#34;%!(NOVERB)&#34;
	invReflectString  = &#34;&lt;invalid reflect.Value&gt;&#34;
)

// State represents the printer state passed to custom formatters.
// It provides access to the io.Writer interface plus information about
// the flags and options for the operand&#39;s format specifier.
type State interface {
	// Write is the function to call to emit formatted output to be printed.
	Write(b []byte) (n int, err error)
	// Width returns the value of the width option and whether it has been set.
	Width() (wid int, ok bool)
	// Precision returns the value of the precision option and whether it has been set.
	Precision() (prec int, ok bool)

	// Flag reports whether the flag c, a character, has been set.
	Flag(c int) bool
}

// Formatter is implemented by any value that has a Format method.
// The implementation controls how State and rune are interpreted,
// and may call Sprint(f) or Fprint(f) etc. to generate its output.
type Formatter interface {
	Format(f State, verb rune)
}

// Stringer is implemented by any value that has a String method,
// which defines the ``native&#39;&#39; format for that value.
// The String method is used to print values passed as an operand
// to any format that accepts a string or to an unformatted printer
// such as Print.
type Stringer interface {
	String() string
}

// GoStringer is implemented by any value that has a GoString method,
// which defines the Go syntax for that value.
// The GoString method is used to print values passed as an operand
// to a %#v format.
type GoStringer interface {
	GoString() string
}

// Use simple []byte instead of bytes.Buffer to avoid large dependency.
type buffer []byte

</pre>
            </td>
            <td>
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (b *buffer) write(p []byte) {
	*b = append(*b, p...)
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.write.png" alt="Control flow graph of write">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (b *buffer) writeString(s string) {
	*b = append(*b, s...)
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.writeString.png" alt="Control flow graph of writeString">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (b *buffer) writeByte(c byte) {
	*b = append(*b, c)
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.writeByte.png" alt="Control flow graph of writeByte">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (bp *buffer) writeRune(r rune) {
	if r &lt; utf8.RuneSelf {
		*bp = append(*bp, byte(r))
		return
	}

	b := *bp
	n := len(b)
	for n&#43;utf8.UTFMax &gt; cap(b) {
		b = append(b, 0)
	}
	w := utf8.EncodeRune(b[n:n&#43;utf8.UTFMax], r)
	*bp = b[:n&#43;w]
}

// pp is used to store a printer&#39;s state and is reused with sync.Pool to avoid allocations.
type pp struct {
	buf buffer

	// arg holds the current item, as an interface{}.
	arg any

	// value is used instead of arg for reflect values.
	value reflect.Value

	// fmt is used to format basic items such as integers or strings.
	fmt fmt

	// reordered records whether the format string used argument reordering.
	reordered bool
	// goodArgNum records whether the most recent reordering directive was valid.
	goodArgNum bool
	// panicking is set by catchPanic to avoid infinite panic, recover, panic, ... recursion.
	panicking bool
	// erroring is set when printing an error string to guard against calling handleMethods.
	erroring bool
	// wrapErrs is set when the format string may contain a %w verb.
	wrapErrs bool
	// wrappedErr records the target of the %w verb.
	wrappedErr error
}

var ppFree = sync.Pool{
</pre>
            </td>
            <td>
                
                    <img src="print.go._.writeRune.png" alt="Control flow graph of writeRune">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>	New: func() any { return new(pp) },
}

// newPrinter allocates a new pp struct or grabs a cached one.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.init$1.png" alt="Control flow graph of init$1">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func newPrinter() *pp {
	p := ppFree.Get().(*pp)
	p.panicking = false
	p.erroring = false
	p.wrapErrs = false
	p.fmt.init(&amp;p.buf)
	return p
}

// free saves used pp structs in ppFree; avoids an allocation per invocation.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.newPrinter.png" alt="Control flow graph of newPrinter">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) free() {
	// Proper usage of a sync.Pool requires each entry to have approximately
	// the same memory cost. To obtain this property when the stored type
	// contains a variably-sized buffer, we add a hard limit on the maximum buffer
	// to place back in the pool.
	//
	// See https://golang.org/issue/23199
	if cap(p.buf) &gt; 64&lt;&lt;10 {
		return
	}

	p.buf = p.buf[:0]
	p.arg = nil
	p.value = reflect.Value{}
	p.wrappedErr = nil
	ppFree.Put(p)
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.free.png" alt="Control flow graph of free">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) Width() (wid int, ok bool) { return p.fmt.wid, p.fmt.widPresent }

</pre>
            </td>
            <td>
                
                    <img src="print.go._.Width.png" alt="Control flow graph of Width">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) Precision() (prec int, ok bool) { return p.fmt.prec, p.fmt.precPresent }

</pre>
            </td>
            <td>
                
                    <img src="print.go._.Precision.png" alt="Control flow graph of Precision">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) Flag(b int) bool {
	switch b {
	case &#39;-&#39;:
		return p.fmt.minus
	case &#39;&#43;&#39;:
		return p.fmt.plus || p.fmt.plusV
	case &#39;#&#39;:
		return p.fmt.sharp || p.fmt.sharpV
	case &#39; &#39;:
		return p.fmt.space
	case &#39;0&#39;:
		return p.fmt.zero
	}
	return false
}

// Implement Write so we can call Fprintf on a pp (through State), for
// recursive use in custom verbs.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Flag.png" alt="Control flow graph of Flag">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) Write(b []byte) (ret int, err error) {
	p.buf.write(b)
	return len(b), nil
}

// Implement WriteString so that we can call io.WriteString
// on a pp (through state), for efficiency.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Write.png" alt="Control flow graph of Write">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) WriteString(s string) (ret int, err error) {
	p.buf.writeString(s)
	return len(s), nil
}

// These routines end in &#39;f&#39; and take a format string.

// Fprintf formats according to a format specifier and writes to w.
// It returns the number of bytes written and any write error encountered.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.WriteString.png" alt="Control flow graph of WriteString">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Fprintf(w io.Writer, format string, a ...any) (n int, err error) {
	p := newPrinter()
	p.doPrintf(format, a)
	n, err = w.Write(p.buf)
	p.free()
	return
}

// Printf formats according to a format specifier and writes to standard output.
// It returns the number of bytes written and any write error encountered.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Fprintf.png" alt="Control flow graph of Fprintf">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Printf(format string, a ...any) (n int, err error) {
	return Fprintf(os.Stdout, format, a...)
}

// Sprintf formats according to a format specifier and returns the resulting string.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Printf.png" alt="Control flow graph of Printf">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Sprintf(format string, a ...any) string {
	p := newPrinter()
	p.doPrintf(format, a)
	s := string(p.buf)
	p.free()
	return s
}

// These routines do not take a format string

// Fprint formats using the default formats for its operands and writes to w.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Sprintf.png" alt="Control flow graph of Sprintf">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Fprint(w io.Writer, a ...any) (n int, err error) {
	p := newPrinter()
	p.doPrint(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}

// Print formats using the default formats for its operands and writes to standard output.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Fprint.png" alt="Control flow graph of Fprint">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Print(a ...any) (n int, err error) {
	return Fprint(os.Stdout, a...)
}

// Sprint formats using the default formats for its operands and returns the resulting string.
// Spaces are added between operands when neither is a string.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Print.png" alt="Control flow graph of Print">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Sprint(a ...any) string {
	p := newPrinter()
	p.doPrint(a)
	s := string(p.buf)
	p.free()
	return s
}

// These routines end in &#39;ln&#39;, do not take a format string,
// always add spaces between operands, and add a newline
// after the last operand.

// Fprintln formats using the default formats for its operands and writes to w.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Sprint.png" alt="Control flow graph of Sprint">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Fprintln(w io.Writer, a ...any) (n int, err error) {
	p := newPrinter()
	p.doPrintln(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}

// Println formats using the default formats for its operands and writes to standard output.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Fprintln.png" alt="Control flow graph of Fprintln">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Println(a ...any) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}

// Sprintln formats using the default formats for its operands and returns the resulting string.
// Spaces are always added between operands and a newline is appended.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Println.png" alt="Control flow graph of Println">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func Sprintln(a ...any) string {
	p := newPrinter()
	p.doPrintln(a)
	s := string(p.buf)
	p.free()
	return s
}

// getField gets the i&#39;th field of the struct value.
// If the field is itself is an interface, return a value for
// the thing inside the interface, not the interface itself.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.Sprintln.png" alt="Control flow graph of Sprintln">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func getField(v reflect.Value, i int) reflect.Value {
	val := v.Field(i)
	if val.Kind() == reflect.Interface &amp;&amp; !val.IsNil() {
		val = val.Elem()
	}
	return val
}

// tooLarge reports whether the magnitude of the integer is
// too large to be used as a formatting width or precision.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.getField.png" alt="Control flow graph of getField">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func tooLarge(x int) bool {
	const max int = 1e6
	return x &gt; max || x &lt; -max
}

// parsenum converts ASCII to integer.  num is 0 (and isnum is false) if no number present.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.tooLarge.png" alt="Control flow graph of tooLarge">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func parsenum(s string, start, end int) (num int, isnum bool, newi int) {
	if start &gt;= end {
		return 0, false, end
	}
	for newi = start; newi &lt; end &amp;&amp; &#39;0&#39; &lt;= s[newi] &amp;&amp; s[newi] &lt;= &#39;9&#39;; newi&#43;&#43; {
		if tooLarge(num) {
			return 0, false, end // Overflow; crazy long number most likely.
		}
		num = num*10 &#43; int(s[newi]-&#39;0&#39;)
		isnum = true
	}
	return
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.parsenum.png" alt="Control flow graph of parsenum">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) unknownType(v reflect.Value) {
	if !v.IsValid() {
		p.buf.writeString(nilAngleString)
		return
	}
	p.buf.writeByte(&#39;?&#39;)
	p.buf.writeString(v.Type().String())
	p.buf.writeByte(&#39;?&#39;)
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.unknownType.png" alt="Control flow graph of unknownType">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) badVerb(verb rune) {
	p.erroring = true
	p.buf.writeString(percentBangString)
	p.buf.writeRune(verb)
	p.buf.writeByte(&#39;(&#39;)
	switch {
	case p.arg != nil:
		p.buf.writeString(reflect.TypeOf(p.arg).String())
		p.buf.writeByte(&#39;=&#39;)
		p.printArg(p.arg, &#39;v&#39;)
	case p.value.IsValid():
		p.buf.writeString(p.value.Type().String())
		p.buf.writeByte(&#39;=&#39;)
		p.printValue(p.value, &#39;v&#39;, 0)
	default:
		p.buf.writeString(nilAngleString)
	}
	p.buf.writeByte(&#39;)&#39;)
	p.erroring = false
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.badVerb.png" alt="Control flow graph of badVerb">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) fmtBool(v bool, verb rune) {
	switch verb {
	case &#39;t&#39;, &#39;v&#39;:
		p.fmt.fmtBoolean(v)
	default:
		p.badVerb(verb)
	}
}

// fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or
// not, as requested, by temporarily setting the sharp flag.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.fmtBool.png" alt="Control flow graph of fmtBool">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) fmt0x64(v uint64, leading0x bool) {
	sharp := p.fmt.sharp
	p.fmt.sharp = leading0x
	p.fmt.fmtInteger(v, 16, unsigned, &#39;v&#39;, ldigits)
	p.fmt.sharp = sharp
}

// fmtInteger formats a signed or unsigned integer.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.fmt0x64.png" alt="Control flow graph of fmt0x64">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) fmtInteger(v uint64, isSigned bool, verb rune) {
	switch verb {
	case &#39;v&#39;:
		if p.fmt.sharpV &amp;&amp; !isSigned {
			p.fmt0x64(v, true)
		} else {
			p.fmt.fmtInteger(v, 10, isSigned, verb, ldigits)
		}
	case &#39;d&#39;:
		p.fmt.fmtInteger(v, 10, isSigned, verb, ldigits)
	case &#39;b&#39;:
		p.fmt.fmtInteger(v, 2, isSigned, verb, ldigits)
	case &#39;o&#39;, &#39;O&#39;:
		p.fmt.fmtInteger(v, 8, isSigned, verb, ldigits)
	case &#39;x&#39;:
		p.fmt.fmtInteger(v, 16, isSigned, verb, ldigits)
	case &#39;X&#39;:
		p.fmt.fmtInteger(v, 16, isSigned, verb, udigits)
	case &#39;c&#39;:
		p.fmt.fmtC(v)
	case &#39;q&#39;:
		p.fmt.fmtQc(v)
	case &#39;U&#39;:
		p.fmt.fmtUnicode(v)
	default:
		p.badVerb(verb)
	}
}

// fmtFloat formats a float. The default precision for each verb
// is specified as last argument in the call to fmt_float.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.fmtInteger.png" alt="Control flow graph of fmtInteger">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) fmtFloat(v float64, size int, verb rune) {
	switch verb {
	case &#39;v&#39;:
		p.fmt.fmtFloat(v, size, &#39;g&#39;, -1)
	case &#39;b&#39;, &#39;g&#39;, &#39;G&#39;, &#39;x&#39;, &#39;X&#39;:
		p.fmt.fmtFloat(v, size, verb, -1)
	case &#39;f&#39;, &#39;e&#39;, &#39;E&#39;:
		p.fmt.fmtFloat(v, size, verb, 6)
	case &#39;F&#39;:
		p.fmt.fmtFloat(v, size, &#39;f&#39;, 6)
	default:
		p.badVerb(verb)
	}
}

// fmtComplex formats a complex number v with
// r = real(v) and j = imag(v) as (r&#43;ji) using
// fmtFloat for r and j formatting.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.fmtFloat.png" alt="Control flow graph of fmtFloat">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) fmtComplex(v complex128, size int, verb rune) {
	// Make sure any unsupported verbs are found before the
	// calls to fmtFloat to not generate an incorrect error string.
	switch verb {
	case &#39;v&#39;, &#39;b&#39;, &#39;g&#39;, &#39;G&#39;, &#39;x&#39;, &#39;X&#39;, &#39;f&#39;, &#39;F&#39;, &#39;e&#39;, &#39;E&#39;:
		oldPlus := p.fmt.plus
		p.buf.writeByte(&#39;(&#39;)
		p.fmtFloat(real(v), size/2, verb)
		// Imaginary part always has a sign.
		p.fmt.plus = true
		p.fmtFloat(imag(v), size/2, verb)
		p.buf.writeString(&#34;i)&#34;)
		p.fmt.plus = oldPlus
	default:
		p.badVerb(verb)
	}
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.fmtComplex.png" alt="Control flow graph of fmtComplex">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) fmtString(v string, verb rune) {
	switch verb {
	case &#39;v&#39;:
		if p.fmt.sharpV {
			p.fmt.fmtQ(v)
		} else {
			p.fmt.fmtS(v)
		}
	case &#39;s&#39;:
		p.fmt.fmtS(v)
	case &#39;x&#39;:
		p.fmt.fmtSx(v, ldigits)
	case &#39;X&#39;:
		p.fmt.fmtSx(v, udigits)
	case &#39;q&#39;:
		p.fmt.fmtQ(v)
	default:
		p.badVerb(verb)
	}
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.fmtString.png" alt="Control flow graph of fmtString">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) fmtBytes(v []byte, verb rune, typeString string) {
	switch verb {
	case &#39;v&#39;, &#39;d&#39;:
		if p.fmt.sharpV {
			p.buf.writeString(typeString)
			if v == nil {
				p.buf.writeString(nilParenString)
				return
			}
			p.buf.writeByte(&#39;{&#39;)
			for i, c := range v {
				if i &gt; 0 {
					p.buf.writeString(commaSpaceString)
				}
				p.fmt0x64(uint64(c), true)
			}
			p.buf.writeByte(&#39;}&#39;)
		} else {
			p.buf.writeByte(&#39;[&#39;)
			for i, c := range v {
				if i &gt; 0 {
					p.buf.writeByte(&#39; &#39;)
				}
				p.fmt.fmtInteger(uint64(c), 10, unsigned, verb, ldigits)
			}
			p.buf.writeByte(&#39;]&#39;)
		}
	case &#39;s&#39;:
		p.fmt.fmtBs(v)
	case &#39;x&#39;:
		p.fmt.fmtBx(v, ldigits)
	case &#39;X&#39;:
		p.fmt.fmtBx(v, udigits)
	case &#39;q&#39;:
		p.fmt.fmtQ(string(v))
	default:
		p.printValue(reflect.ValueOf(v), verb, 0)
	}
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.fmtBytes.png" alt="Control flow graph of fmtBytes">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) fmtPointer(value reflect.Value, verb rune) {
	var u uintptr
	switch value.Kind() {
	case reflect.Chan, reflect.Func, reflect.Map, reflect.Pointer, reflect.Slice, reflect.UnsafePointer:
		u = value.Pointer()
	default:
		p.badVerb(verb)
		return
	}

	switch verb {
	case &#39;v&#39;:
		if p.fmt.sharpV {
			p.buf.writeByte(&#39;(&#39;)
			p.buf.writeString(value.Type().String())
			p.buf.writeString(&#34;)(&#34;)
			if u == 0 {
				p.buf.writeString(nilString)
			} else {
				p.fmt0x64(uint64(u), true)
			}
			p.buf.writeByte(&#39;)&#39;)
		} else {
			if u == 0 {
				p.fmt.padString(nilAngleString)
			} else {
				p.fmt0x64(uint64(u), !p.fmt.sharp)
			}
		}
	case &#39;p&#39;:
		p.fmt0x64(uint64(u), !p.fmt.sharp)
	case &#39;b&#39;, &#39;o&#39;, &#39;d&#39;, &#39;x&#39;, &#39;X&#39;:
		p.fmtInteger(uint64(u), unsigned, verb)
	default:
		p.badVerb(verb)
	}
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.fmtPointer.png" alt="Control flow graph of fmtPointer">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) catchPanic(arg any, verb rune, method string) {
	if err := recover(); err != nil {
		// If it&#39;s a nil pointer, just say &#34;&lt;nil&gt;&#34;. The likeliest causes are a
		// Stringer that fails to guard against nil or a nil pointer for a
		// value receiver, and in either case, &#34;&lt;nil&gt;&#34; is a nice result.
		if v := reflect.ValueOf(arg); v.Kind() == reflect.Pointer &amp;&amp; v.IsNil() {
			p.buf.writeString(nilAngleString)
			return
		}
		// Otherwise print a concise panic message. Most of the time the panic
		// value will print itself nicely.
		if p.panicking {
			// Nested panics; the recursion in printArg cannot succeed.
			panic(err)
		}

		oldFlags := p.fmt.fmtFlags
		// For this output we want default behavior.
		p.fmt.clearflags()

		p.buf.writeString(percentBangString)
		p.buf.writeRune(verb)
		p.buf.writeString(panicString)
		p.buf.writeString(method)
		p.buf.writeString(&#34; method: &#34;)
		p.panicking = true
		p.printArg(err, &#39;v&#39;)
		p.panicking = false
		p.buf.writeByte(&#39;)&#39;)

		p.fmt.fmtFlags = oldFlags
	}
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.catchPanic.png" alt="Control flow graph of catchPanic">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) handleMethods(verb rune) (handled bool) {
	if p.erroring {
		return
	}
	if verb == &#39;w&#39; {
		// It is invalid to use %w other than with Errorf, more than once,
		// or with a non-error arg.
		err, ok := p.arg.(error)
		if !ok || !p.wrapErrs || p.wrappedErr != nil {
			p.wrappedErr = nil
			p.wrapErrs = false
			p.badVerb(verb)
			return true
		}
		p.wrappedErr = err
		// If the arg is a Formatter, pass &#39;v&#39; as the verb to it.
		verb = &#39;v&#39;
	}

	// Is it a Formatter?
	if formatter, ok := p.arg.(Formatter); ok {
		handled = true
		defer p.catchPanic(p.arg, verb, &#34;Format&#34;)
		formatter.Format(p, verb)
		return
	}

	// If we&#39;re doing Go syntax and the argument knows how to supply it, take care of it now.
	if p.fmt.sharpV {
		if stringer, ok := p.arg.(GoStringer); ok {
			handled = true
			defer p.catchPanic(p.arg, verb, &#34;GoString&#34;)
			// Print the result of GoString unadorned.
			p.fmt.fmtS(stringer.GoString())
			return
		}
	} else {
		// If a string is acceptable according to the format, see if
		// the value satisfies one of the string-valued interfaces.
		// Println etc. set verb to %v, which is &#34;stringable&#34;.
		switch verb {
		case &#39;v&#39;, &#39;s&#39;, &#39;x&#39;, &#39;X&#39;, &#39;q&#39;:
			// Is it an error or Stringer?
			// The duplication in the bodies is necessary:
			// setting handled and deferring catchPanic
			// must happen before calling the method.
			switch v := p.arg.(type) {
			case error:
				handled = true
				defer p.catchPanic(p.arg, verb, &#34;Error&#34;)
				p.fmtString(v.Error(), verb)
				return

			case Stringer:
				handled = true
				defer p.catchPanic(p.arg, verb, &#34;String&#34;)
				p.fmtString(v.String(), verb)
				return
			}
		}
	}
	return false
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.handleMethods.png" alt="Control flow graph of handleMethods">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) printArg(arg any, verb rune) {
	p.arg = arg
	p.value = reflect.Value{}

	if arg == nil {
		switch verb {
		case &#39;T&#39;, &#39;v&#39;:
			p.fmt.padString(nilAngleString)
		default:
			p.badVerb(verb)
		}
		return
	}

	// Special processing considerations.
	// %T (the value&#39;s type) and %p (its address) are special; we always do them first.
	switch verb {
	case &#39;T&#39;:
		p.fmt.fmtS(reflect.TypeOf(arg).String())
		return
	case &#39;p&#39;:
		p.fmtPointer(reflect.ValueOf(arg), &#39;p&#39;)
		return
	}

	// Some types can be done without reflection.
	switch f := arg.(type) {
	case bool:
		p.fmtBool(f, verb)
	case float32:
		p.fmtFloat(float64(f), 32, verb)
	case float64:
		p.fmtFloat(f, 64, verb)
	case complex64:
		p.fmtComplex(complex128(f), 64, verb)
	case complex128:
		p.fmtComplex(f, 128, verb)
	case int:
		p.fmtInteger(uint64(f), signed, verb)
	case int8:
		p.fmtInteger(uint64(f), signed, verb)
	case int16:
		p.fmtInteger(uint64(f), signed, verb)
	case int32:
		p.fmtInteger(uint64(f), signed, verb)
	case int64:
		p.fmtInteger(uint64(f), signed, verb)
	case uint:
		p.fmtInteger(uint64(f), unsigned, verb)
	case uint8:
		p.fmtInteger(uint64(f), unsigned, verb)
	case uint16:
		p.fmtInteger(uint64(f), unsigned, verb)
	case uint32:
		p.fmtInteger(uint64(f), unsigned, verb)
	case uint64:
		p.fmtInteger(f, unsigned, verb)
	case uintptr:
		p.fmtInteger(uint64(f), unsigned, verb)
	case string:
		p.fmtString(f, verb)
	case []byte:
		p.fmtBytes(f, verb, &#34;[]byte&#34;)
	case reflect.Value:
		// Handle extractable values with special methods
		// since printValue does not handle them at depth 0.
		if f.IsValid() &amp;&amp; f.CanInterface() {
			p.arg = f.Interface()
			if p.handleMethods(verb) {
				return
			}
		}
		p.printValue(f, verb, 0)
	default:
		// If the type is not simple, it might have methods.
		if !p.handleMethods(verb) {
			// Need to use reflection, since the type had no
			// interface methods that could be used for formatting.
			p.printValue(reflect.ValueOf(f), verb, 0)
		}
	}
}

// printValue is similar to printArg but starts with a reflect value, not an interface{} value.
// It does not handle &#39;p&#39; and &#39;T&#39; verbs because these should have been already handled by printArg.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.printArg.png" alt="Control flow graph of printArg">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) printValue(value reflect.Value, verb rune, depth int) {
	// Handle values with special methods if not already handled by printArg (depth == 0).
	if depth &gt; 0 &amp;&amp; value.IsValid() &amp;&amp; value.CanInterface() {
		p.arg = value.Interface()
		if p.handleMethods(verb) {
			return
		}
	}
	p.arg = nil
	p.value = value

	switch f := value; value.Kind() {
	case reflect.Invalid:
		if depth == 0 {
			p.buf.writeString(invReflectString)
		} else {
			switch verb {
			case &#39;v&#39;:
				p.buf.writeString(nilAngleString)
			default:
				p.badVerb(verb)
			}
		}
	case reflect.Bool:
		p.fmtBool(f.Bool(), verb)
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		p.fmtInteger(uint64(f.Int()), signed, verb)
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		p.fmtInteger(f.Uint(), unsigned, verb)
	case reflect.Float32:
		p.fmtFloat(f.Float(), 32, verb)
	case reflect.Float64:
		p.fmtFloat(f.Float(), 64, verb)
	case reflect.Complex64:
		p.fmtComplex(f.Complex(), 64, verb)
	case reflect.Complex128:
		p.fmtComplex(f.Complex(), 128, verb)
	case reflect.String:
		p.fmtString(f.String(), verb)
	case reflect.Map:
		if p.fmt.sharpV {
			p.buf.writeString(f.Type().String())
			if f.IsNil() {
				p.buf.writeString(nilParenString)
				return
			}
			p.buf.writeByte(&#39;{&#39;)
		} else {
			p.buf.writeString(mapString)
		}
		sorted := fmtsort.Sort(f)
		for i, key := range sorted.Key {
			if i &gt; 0 {
				if p.fmt.sharpV {
					p.buf.writeString(commaSpaceString)
				} else {
					p.buf.writeByte(&#39; &#39;)
				}
			}
			p.printValue(key, verb, depth&#43;1)
			p.buf.writeByte(&#39;:&#39;)
			p.printValue(sorted.Value[i], verb, depth&#43;1)
		}
		if p.fmt.sharpV {
			p.buf.writeByte(&#39;}&#39;)
		} else {
			p.buf.writeByte(&#39;]&#39;)
		}
	case reflect.Struct:
		if p.fmt.sharpV {
			p.buf.writeString(f.Type().String())
		}
		p.buf.writeByte(&#39;{&#39;)
		for i := 0; i &lt; f.NumField(); i&#43;&#43; {
			if i &gt; 0 {
				if p.fmt.sharpV {
					p.buf.writeString(commaSpaceString)
				} else {
					p.buf.writeByte(&#39; &#39;)
				}
			}
			if p.fmt.plusV || p.fmt.sharpV {
				if name := f.Type().Field(i).Name; name != &#34;&#34; {
					p.buf.writeString(name)
					p.buf.writeByte(&#39;:&#39;)
				}
			}
			p.printValue(getField(f, i), verb, depth&#43;1)
		}
		p.buf.writeByte(&#39;}&#39;)
	case reflect.Interface:
		value := f.Elem()
		if !value.IsValid() {
			if p.fmt.sharpV {
				p.buf.writeString(f.Type().String())
				p.buf.writeString(nilParenString)
			} else {
				p.buf.writeString(nilAngleString)
			}
		} else {
			p.printValue(value, verb, depth&#43;1)
		}
	case reflect.Array, reflect.Slice:
		switch verb {
		case &#39;s&#39;, &#39;q&#39;, &#39;x&#39;, &#39;X&#39;:
			// Handle byte and uint8 slices and arrays special for the above verbs.
			t := f.Type()
			if t.Elem().Kind() == reflect.Uint8 {
				var bytes []byte
				if f.Kind() == reflect.Slice {
					bytes = f.Bytes()
				} else if f.CanAddr() {
					bytes = f.Slice(0, f.Len()).Bytes()
				} else {
					// We have an array, but we cannot Slice() a non-addressable array,
					// so we build a slice by hand. This is a rare case but it would be nice
					// if reflection could help a little more.
					bytes = make([]byte, f.Len())
					for i := range bytes {
						bytes[i] = byte(f.Index(i).Uint())
					}
				}
				p.fmtBytes(bytes, verb, t.String())
				return
			}
		}
		if p.fmt.sharpV {
			p.buf.writeString(f.Type().String())
			if f.Kind() == reflect.Slice &amp;&amp; f.IsNil() {
				p.buf.writeString(nilParenString)
				return
			}
			p.buf.writeByte(&#39;{&#39;)
			for i := 0; i &lt; f.Len(); i&#43;&#43; {
				if i &gt; 0 {
					p.buf.writeString(commaSpaceString)
				}
				p.printValue(f.Index(i), verb, depth&#43;1)
			}
			p.buf.writeByte(&#39;}&#39;)
		} else {
			p.buf.writeByte(&#39;[&#39;)
			for i := 0; i &lt; f.Len(); i&#43;&#43; {
				if i &gt; 0 {
					p.buf.writeByte(&#39; &#39;)
				}
				p.printValue(f.Index(i), verb, depth&#43;1)
			}
			p.buf.writeByte(&#39;]&#39;)
		}
	case reflect.Pointer:
		// pointer to array or slice or struct? ok at top level
		// but not embedded (avoid loops)
		if depth == 0 &amp;&amp; f.Pointer() != 0 {
			switch a := f.Elem(); a.Kind() {
			case reflect.Array, reflect.Slice, reflect.Struct, reflect.Map:
				p.buf.writeByte(&#39;&amp;&#39;)
				p.printValue(a, verb, depth&#43;1)
				return
			}
		}
		fallthrough
	case reflect.Chan, reflect.Func, reflect.UnsafePointer:
		p.fmtPointer(f, verb)
	default:
		p.unknownType(f)
	}
}

// intFromArg gets the argNumth element of a. On return, isInt reports whether the argument has integer type.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.printValue.png" alt="Control flow graph of printValue">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func intFromArg(a []any, argNum int) (num int, isInt bool, newArgNum int) {
	newArgNum = argNum
	if argNum &lt; len(a) {
		num, isInt = a[argNum].(int) // Almost always OK.
		if !isInt {
			// Work harder.
			switch v := reflect.ValueOf(a[argNum]); v.Kind() {
			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
				n := v.Int()
				if int64(int(n)) == n {
					num = int(n)
					isInt = true
				}
			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
				n := v.Uint()
				if int64(n) &gt;= 0 &amp;&amp; uint64(int(n)) == n {
					num = int(n)
					isInt = true
				}
			default:
				// Already 0, false.
			}
		}
		newArgNum = argNum &#43; 1
		if tooLarge(num) {
			num = 0
			isInt = false
		}
	}
	return
}

// parseArgNumber returns the value of the bracketed number, minus 1
// (explicit argument numbers are one-indexed but we want zero-indexed).
// The opening bracket is known to be present at format[0].
// The returned values are the index, the number of bytes to consume
// up to the closing paren, if present, and whether the number parsed
// ok. The bytes to consume will be 1 if no closing paren is present.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.intFromArg.png" alt="Control flow graph of intFromArg">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func parseArgNumber(format string) (index int, wid int, ok bool) {
	// There must be at least 3 bytes: [n].
	if len(format) &lt; 3 {
		return 0, 1, false
	}

	// Find closing bracket.
	for i := 1; i &lt; len(format); i&#43;&#43; {
		if format[i] == &#39;]&#39; {
			width, ok, newi := parsenum(format, 1, i)
			if !ok || newi != i {
				return 0, i &#43; 1, false
			}
			return width - 1, i &#43; 1, true // arg numbers are one-indexed and skip paren.
		}
	}
	return 0, 1, false
}

// argNumber returns the next argument to evaluate, which is either the value of the passed-in
// argNum or the value of the bracketed integer that begins format[i:]. It also returns
// the new value of i, that is, the index of the next byte of the format to process.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.parseArgNumber.png" alt="Control flow graph of parseArgNumber">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) argNumber(argNum int, format string, i int, numArgs int) (newArgNum, newi int, found bool) {
	if len(format) &lt;= i || format[i] != &#39;[&#39; {
		return argNum, i, false
	}
	p.reordered = true
	index, wid, ok := parseArgNumber(format[i:])
	if ok &amp;&amp; 0 &lt;= index &amp;&amp; index &lt; numArgs {
		return index, i &#43; wid, true
	}
	p.goodArgNum = false
	return argNum, i &#43; wid, ok
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.argNumber.png" alt="Control flow graph of argNumber">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) badArgNum(verb rune) {
	p.buf.writeString(percentBangString)
	p.buf.writeRune(verb)
	p.buf.writeString(badIndexString)
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.badArgNum.png" alt="Control flow graph of badArgNum">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) missingArg(verb rune) {
	p.buf.writeString(percentBangString)
	p.buf.writeRune(verb)
	p.buf.writeString(missingString)
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.missingArg.png" alt="Control flow graph of missingArg">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) doPrintf(format string, a []any) {
	end := len(format)
	argNum := 0         // we process one argument per non-trivial format
	afterIndex := false // previous item in format was an index like [3].
	p.reordered = false
formatLoop:
	for i := 0; i &lt; end; {
		p.goodArgNum = true
		lasti := i
		for i &lt; end &amp;&amp; format[i] != &#39;%&#39; {
			i&#43;&#43;
		}
		if i &gt; lasti {
			p.buf.writeString(format[lasti:i])
		}
		if i &gt;= end {
			// done processing format string
			break
		}

		// Process one verb
		i&#43;&#43;

		// Do we have flags?
		p.fmt.clearflags()
	simpleFormat:
		for ; i &lt; end; i&#43;&#43; {
			c := format[i]
			switch c {
			case &#39;#&#39;:
				p.fmt.sharp = true
			case &#39;0&#39;:
				p.fmt.zero = !p.fmt.minus // Only allow zero padding to the left.
			case &#39;&#43;&#39;:
				p.fmt.plus = true
			case &#39;-&#39;:
				p.fmt.minus = true
				p.fmt.zero = false // Do not pad with zeros to the right.
			case &#39; &#39;:
				p.fmt.space = true
			default:
				// Fast path for common case of ascii lower case simple verbs
				// without precision or width or argument indices.
				if &#39;a&#39; &lt;= c &amp;&amp; c &lt;= &#39;z&#39; &amp;&amp; argNum &lt; len(a) {
					if c == &#39;v&#39; {
						// Go syntax
						p.fmt.sharpV = p.fmt.sharp
						p.fmt.sharp = false
						// Struct-field syntax
						p.fmt.plusV = p.fmt.plus
						p.fmt.plus = false
					}
					p.printArg(a[argNum], rune(c))
					argNum&#43;&#43;
					i&#43;&#43;
					continue formatLoop
				}
				// Format is more complex than simple flags and a verb or is malformed.
				break simpleFormat
			}
		}

		// Do we have an explicit argument index?
		argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))

		// Do we have width?
		if i &lt; end &amp;&amp; format[i] == &#39;*&#39; {
			i&#43;&#43;
			p.fmt.wid, p.fmt.widPresent, argNum = intFromArg(a, argNum)

			if !p.fmt.widPresent {
				p.buf.writeString(badWidthString)
			}

			// We have a negative width, so take its value and ensure
			// that the minus flag is set
			if p.fmt.wid &lt; 0 {
				p.fmt.wid = -p.fmt.wid
				p.fmt.minus = true
				p.fmt.zero = false // Do not pad with zeros to the right.
			}
			afterIndex = false
		} else {
			p.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end)
			if afterIndex &amp;&amp; p.fmt.widPresent { // &#34;%[3]2d&#34;
				p.goodArgNum = false
			}
		}

		// Do we have precision?
		if i&#43;1 &lt; end &amp;&amp; format[i] == &#39;.&#39; {
			i&#43;&#43;
			if afterIndex { // &#34;%[3].2d&#34;
				p.goodArgNum = false
			}
			argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
			if i &lt; end &amp;&amp; format[i] == &#39;*&#39; {
				i&#43;&#43;
				p.fmt.prec, p.fmt.precPresent, argNum = intFromArg(a, argNum)
				// Negative precision arguments don&#39;t make sense
				if p.fmt.prec &lt; 0 {
					p.fmt.prec = 0
					p.fmt.precPresent = false
				}
				if !p.fmt.precPresent {
					p.buf.writeString(badPrecString)
				}
				afterIndex = false
			} else {
				p.fmt.prec, p.fmt.precPresent, i = parsenum(format, i, end)
				if !p.fmt.precPresent {
					p.fmt.prec = 0
					p.fmt.precPresent = true
				}
			}
		}

		if !afterIndex {
			argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
		}

		if i &gt;= end {
			p.buf.writeString(noVerbString)
			break
		}

		verb, size := rune(format[i]), 1
		if verb &gt;= utf8.RuneSelf {
			verb, size = utf8.DecodeRuneInString(format[i:])
		}
		i &#43;= size

		switch {
		case verb == &#39;%&#39;: // Percent does not absorb operands and ignores f.wid and f.prec.
			p.buf.writeByte(&#39;%&#39;)
		case !p.goodArgNum:
			p.badArgNum(verb)
		case argNum &gt;= len(a): // No argument left over to print for the current verb.
			p.missingArg(verb)
		case verb == &#39;v&#39;:
			// Go syntax
			p.fmt.sharpV = p.fmt.sharp
			p.fmt.sharp = false
			// Struct-field syntax
			p.fmt.plusV = p.fmt.plus
			p.fmt.plus = false
			fallthrough
		default:
			p.printArg(a[argNum], verb)
			argNum&#43;&#43;
		}
	}

	// Check for extra arguments unless the call accessed the arguments
	// out of order, in which case it&#39;s too expensive to detect if they&#39;ve all
	// been used and arguably OK if they&#39;re not.
	if !p.reordered &amp;&amp; argNum &lt; len(a) {
		p.fmt.clearflags()
		p.buf.writeString(extraString)
		for i, arg := range a[argNum:] {
			if i &gt; 0 {
				p.buf.writeString(commaSpaceString)
			}
			if arg == nil {
				p.buf.writeString(nilAngleString)
			} else {
				p.buf.writeString(reflect.TypeOf(arg).String())
				p.buf.writeByte(&#39;=&#39;)
				p.printArg(arg, &#39;v&#39;)
			}
		}
		p.buf.writeByte(&#39;)&#39;)
	}
}

</pre>
            </td>
            <td>
                
                    <img src="print.go._.doPrintf.png" alt="Control flow graph of doPrintf">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) doPrint(a []any) {
	prevString := false
	for argNum, arg := range a {
		isString := arg != nil &amp;&amp; reflect.TypeOf(arg).Kind() == reflect.String
		// Add a space between two non-string arguments.
		if argNum &gt; 0 &amp;&amp; !isString &amp;&amp; !prevString {
			p.buf.writeByte(&#39; &#39;)
		}
		p.printArg(arg, &#39;v&#39;)
		prevString = isString
	}
}

// doPrintln is like doPrint but always adds a space between arguments
// and a newline after the last argument.
</pre>
            </td>
            <td>
                
                    <img src="print.go._.doPrint.png" alt="Control flow graph of doPrint">
                
            </td>
        </tr>
    
        <tr>
            <td>
            <pre>func (p *pp) doPrintln(a []any) {
	for argNum, arg := range a {
		if argNum &gt; 0 {
			p.buf.writeByte(&#39; &#39;)
		}
		p.printArg(arg, &#39;v&#39;)
	}
	p.buf.writeByte(&#39;\n&#39;)
}
</pre>
            </td>
            <td>
                
                    <img src="print.go._.doPrintln.png" alt="Control flow graph of doPrintln">
                
            </td>
        </tr>
    
</table>
</body>
</html>